[["index.html", "Introduction to spatial-temporal data anlysis using R 本稿の目的", " Introduction to spatial-temporal data anlysis using R Tsubasa Yamaguchi 2023-09-09 本稿の目的 本稿は、一般化加法モデル(GAM)の概要を解説し、それをRで実行する方法を学ぶことを目的とする。本稿の内容はこちらから読むことができる。 GAMは一般化線形モデル(GLMに代表される線形なモデルを拡張し、変数間の関係をより柔軟な形で表現できるようにしたものである。そのため、GLMで仮定されるような単調増加または単調減少の関係だけでなく、非線形な関係を調べることができる。 霊長類の行動のような複雑なデータでは変数間の関係が非線形になることがしばしばあるため、GAMは多くの研究で用いられている(e.g., Matsumoto2017?; Taniguchi2018?; Hongo2022?)。GLMのように線形性を仮定するモデルがデータに当てはまらない場合には、GAMなどの非線形性を許容するモデルを使用する必要性が生じてくるだろう。 本稿は、Alain Zuurが執筆した”A beginner’s guide to generalized additive models with R”(Zuur2012?)の内容を基に執筆している。本書はなるべく数学的な説明を省きつつ、実際の生態学のデータを用いてGAMについてわかりやすく解説したもので、GAMの入門として非常によい書籍である。より詳細な情報を知りたい場合は原著にアクセスしていただきたい。 その他に参考にしたのは以下の本である。 (Zuur2009?) Mixed effects models and extensions in ecology with R. (James2013?) An Introduction to Statistical Learning with Applications in R. (Takezawa2009?) Rによるノンパラメトリック回帰の入門講義 "],["Chapter0.html", "0. パッケージの読み込み", " 0. パッケージの読み込み 本稿はRの基本操作とtidyverseパッケージによるデータハンドリングができることを前提としている。tidyverseパッケージを用いたデータ処理については、以下の書籍などを参照。 R for Data Science (Wickham2016?) 電子書籍, 日本語 R Graphics Coocbook 2nd Edition (Chang2018?) 電子書籍, 日本語 RユーザのためのRstudio[実践]入門~tidyverseによるモダンな分析フローの世界 改訂2版 (Matsumura2021?) 出版社サイト 使用するパッケージは以下のとおりである。GAMの実行は主にgamパッケージ(Hastie2018?)を用い、結果の作図についてはggplotパッケージでGAMの結果を可視化することに特化したgratiaパッケージを用いる。 ## 地理データ library(sp) library(sf) library(NipponMap) ## GAM library(mgcv) library(gamm4) library(nlme) library(gamlss) library(gratia) library(gstat) library(MASS) library(brms) library(rstan) library(cmdstanr) library(DHARMa) library(DHARMa.helpers) library(ggeffects) ## データハンドリング library(tidyverse) library(easystats) library(data.table) library(lubridate) ## グラフや表関連 library(scales) library(geoR) library(sp) library(plotly) library(htmlwidgets) library(ggnewscale) library(GGally) library(ggrepel) library(patchwork) library(DT) library(knitr) library(kableExtra) library(dagitty) library(ggdag) library(ggforce) library(concaveman) library(ggsci) library(lemon) library(gganimate) ## フォント関連 library(extrafont) require(systemfonts) require(fontregisterer) "],["Chapter2.html", "1 Recognizing statistical dependency 1.1 Pseudoreplication 1.2 Linear regression applied to spatial data 1.3 GAM applied to temporal data", " 1 Recognizing statistical dependency 1.1 Pseudoreplication 1.1.1 疑似反復とは 疑似反復(pseudoreplication)とは、応答変数のデータが独立ではないにもかかわらず、統計解析にそのことが考慮されていないことを指す。多くの統計解析は全てのデータが独立であることを仮定しているので、もし疑似反復が生じている状態で分析を行うと正しい結果が得られないことが多い。 疑似反復の典型的な例としては、同じ個体から複数のデータが得られている場合が挙げられる。例えば、ある治療薬の効果を調べる場合、各患者について治療前のデータと治療薬を飲んだ後のデータを収集する。もし100人分データを収集するとすれば200個のデータが集まるが、これらのデータが独立であると考えることはできない。なぜなら、同じ患者のデータはその患者特有の属性など(年齢、性別、あるいは観測できない要因など)によって他の患者のデータよりも類似している可能性が高くなるからである。もし独立であると仮定して分析を行うと、実際よりもデータの標準誤差が小さく推定されてしまい、第一種の過誤を犯しやすくなってしまう。 他にも、例えば10個の植木鉢にそれぞれ5個ずつ種子を植えて、その成長度合いを調べる場合を考えてみよう。このとき、合計50個のデータが得られるが、同じ植木鉢に植えられた種子のデータを独立であると考えることはできない。なぜなら、同じ植木鉢の種子はその植木鉢特有の属性(土中の栄養分、日照度合い、あるいは観測できない要因など)によって、他の植木鉢の種子のデータよりも類似している可能性が高くなるからである。 こうした疑似反復に対処するためのアプローチは、混合モデルと呼ばれるものを適用することである(Zuur et al. 2013)。 1.1.2 時空間的な疑似反復 上記のような疑似反復の他にも、時間的あるいは空間的な疑似反復が生じることがある。例えば、あるニホンザルの群れで発情しているメスの数を毎日記録するとしよう。このとき、時間的に近い日のデータ同士はそうでないデータ同士よりも類似する確率が高い。なぜなら、ある日発情していたメスは、その次の日も発情している可能性が高いからである。 図1.1は実際に宮城県金華山島で収集された発情メス数のデータである。実際に、近い日は類似した値をとることが多いことが分かる。このように、時系列データは互いに独立していないことが多い。こうした時間的な疑似相関を考慮せずに分析を行ってしまう(e.g., 毎日の発情メス数が気温によって変わるかを調べるなど)と、誤った結論を導いてしまいかねない。 daily_data &lt;- read_csv(&quot;data/daily_data_2021.csv&quot;) daily_data %&gt;% filter(duration &gt;= 300) %&gt;% ggplot(aes(x = date))+ geom_line(aes(y = no_est))+ scale_x_date(date_breaks = &quot;1 week&quot;)+ scale_y_continuous(breaks = seq(0,16,2))+ theme_bw(base_size=15)+ theme(axis.text.x = element_text(angle=30, hjust=1), axis.title.y = element_text(angle = 0, vjust = 0.5), aspect.ratio=0.5, legend.position = c(0.2,0.9), legend.text = element_text(size=10.5, family = &quot;Yu Mincho&quot;), axis.text = element_text(family = &quot;Times New Roman&quot;))+ labs(x = &quot;&quot;, y = &quot;発\\n情\\nメ\\nス\\n数&quot;)+ guides(linetype = guide_legend(title=NULL)) 図1.1: 2021年の金華山島B1群における各観察日の発情メス数 地理空間データについても同様のことがいえる。例えば、日本の各都道府県における納豆の消費量について分析するとする(データはこちらから)。このとき、各都道府県のデータを独立と考えることはできない。なぜなら、地理的に近い都道府県は食文化や気候などが類似しており、納豆の消費量も類似している可能性が高くなるからである。 実際、地図上に納豆消費量を図示すると(図1.2)、地理的に近い県は納豆の消費量も類似していることが分かる。このように、空間的データについてもデータ同士に非独立性が生じやすい。 natto &lt;- read_csv(&quot;data/natto.csv&quot;) gyuniku &lt;- read_csv(&quot;data/gyuniku.csv&quot;) shp &lt;- system.file(&quot;shapes/jpn.shp&quot;, package = &quot;NipponMap&quot;)[1] pref &lt;- read_sf(shp) %&gt;% rename(prefecture = name) natto %&gt;% left_join(gyuniku) %&gt;% left_join(pref) -&gt; japan_data japan_data %&gt;% filter(prefecture != &quot;Okinawa&quot;) %&gt;% ggplot()+ geom_sf(aes(geometry = geometry, fill = natto))+ theme_void()+ theme(aspect.ratio = 1)+ scale_fill_gradient2(high = muted(&quot;blue&quot;), low = muted(&quot;red&quot;), mid = &quot;white&quot;, midpoint = 3700)+ labs(fill = &quot;納豆消費量(円)&quot;) 図1.2: 各都道府県の納豆消費量(円) こうした空間的な疑似反復を考慮せずに分析を行ってしまうと、誤った結論を導いてしまうことになる。例えば、各都道府県の納豆消費量と牛肉消費量が関連しているかを分析するとしよう。図1.3は両者の関連をプロットしたものであるが、プロットだけを見ると両社は強い負の相関を持つように見える(実際、相関係数は-0.737。しかし、先ほど見たように各都道府県のデータは独立ではないので、空間的な非独立性を考慮した分析を行わなければいけない。空間的相関を考慮した分析を行うと、両者の関連はなくなる(こちらを参照)。 japan_data %&gt;% ggplot(aes(x = gyuniku, y = natto))+ geom_point(shape = 1, size = 2)+ theme_bw()+ theme(aspect.ratio = 1)+ labs(y = &quot;納豆消費量(円)&quot;, x = &quot;牛肉消費量(g)&quot;) 図1.3: 各都道府県の納豆消費量と牛肉消費量 1.2 Linear regression applied to spatial data 本節では、Cruikshanks et al. (2006) のデータを用いる。この研究では、アイルランドの257の川において、川のpHがSDI(Sodium Dominance Index; 陽イオン中のナトリウムイオン)と関連しているかを、緯度(Altitude)やその場所が森林化されているか(Forested)も考慮したうえで調べている。 1.2.1 Visualization データは以下の通り。 iph &lt;- read_delim(&quot;data/Irishph.txt&quot;) %&gt;% mutate(fForested = ifelse(Forested == &quot;1&quot;, &quot;yes&quot;, &quot;no&quot;)) %&gt;% data.frame() datatable(iph, options = list(scrollX = 20), filter = &quot;top&quot;) 各説明変数との関連は以下の通り。 iph %&gt;% select(Altitude, pH, fForested, SDI) %&gt;% pivot_longer(cols = c(Altitude, SDI)) %&gt;% ggplot(aes(x = value, y = pH))+ geom_point(aes(color = fForested))+ geom_smooth(aes(color = fForested), method = &quot;lm&quot;)+ facet_rep_wrap(~ name, scales = &quot;free_x&quot;, repeat.tick.labels = TRUE)+ theme_bw()+ theme(aspect.ratio = 1)+ labs(x = &quot;Covariates&quot;) 1.2.2 Dependency 以下の線形モデルを適用するとする。 \\[ \\begin{aligned} pH_i &amp;\\sim N(0,\\sigma^2)\\\\ \\mu_i &amp;= \\beta_1 + \\beta_2 \\times SDI_i\\\\ \\end{aligned} \\] 結果を図示すると以下のようになる。 m2_1 &lt;- lm(pH ~ SDI, data = iph) ggpredict(m2_1, terms = &quot;SDI[7:72,by=0.1]&quot;, interval = &quot;prediction&quot;) %&gt;% data.frame() %&gt;% mutate(type = &quot;prediction&quot;) %&gt;% bind_rows(ggpredict(m2_1, terms = &quot;SDI[7:72,by=0.1]&quot;, interval = &quot;confidence&quot;) %&gt;% data.frame() %&gt;% mutate(type = &quot;confidence&quot;)) %&gt;% rename(SDI = x) %&gt;% ggplot(aes(x = SDI, y = predicted))+ geom_ribbon(aes(ymin = conf.high, ymax = conf.low, fill = type), alpha = 0.5)+ scale_fill_grey()+ geom_line()+ geom_point(data = iph, aes(y = pH), shape = 1)+ theme_bw()+ theme(aspect.ratio = 1) 1.2.3 Fit the model 全部の交互作用を含むモデルを考える。 iph %&gt;% mutate(logAltitude = log(Altitude,10)) -&gt; iph m2_2 &lt;- lm(pH ~ SDI*fForested*logAltitude, data = iph) 結果は以下の通り。 summary(m2_2) ## ## Call: ## lm(formula = pH ~ SDI * fForested * logAltitude, data = iph) ## ## Residuals: ## Min 1Q Median 3Q Max ## -1.94554 -0.18644 -0.01226 0.21667 1.13820 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 8.250624 0.765918 10.772 &lt;2e-16 *** ## SDI -0.028011 0.017190 -1.630 0.105 ## fForestedyes 1.794536 2.070682 0.867 0.387 ## logAltitude 0.046122 0.169691 0.272 0.786 ## SDI:fForestedyes -0.008168 0.037112 -0.220 0.826 ## SDI:logAltitude 0.000766 0.003741 0.205 0.838 ## fForestedyes:logAltitude -0.384565 0.439572 -0.875 0.383 ## SDI:fForestedyes:logAltitude 0.001552 0.007791 0.199 0.842 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.3756 on 202 degrees of freedom ## Multiple R-squared: 0.5675, Adjusted R-squared: 0.5525 ## F-statistic: 37.86 on 7 and 202 DF, p-value: &lt; 2.2e-16 あまりに煩雑なのでAICによるモデル選択を行う。 stepAIC(m2_2) ## Start: AIC=-403.47 ## pH ~ SDI * fForested * logAltitude ## ## Df Sum of Sq RSS AIC ## - SDI:fForested:logAltitude 1 0.0055954 28.498 -405.43 ## &lt;none&gt; 28.492 -403.47 ## ## Step: AIC=-405.43 ## pH ~ SDI + fForested + logAltitude + SDI:fForested + SDI:logAltitude + ## fForested:logAltitude ## ## Df Sum of Sq RSS AIC ## - SDI:fForested 1 0.00454 28.503 -407.39 ## - SDI:logAltitude 1 0.01654 28.515 -407.31 ## &lt;none&gt; 28.498 -405.43 ## - fForested:logAltitude 1 1.01027 29.508 -400.11 ## ## Step: AIC=-407.39 ## pH ~ SDI + fForested + logAltitude + SDI:logAltitude + fForested:logAltitude ## ## Df Sum of Sq RSS AIC ## - SDI:logAltitude 1 0.01443 28.517 -409.29 ## &lt;none&gt; 28.503 -407.39 ## - fForested:logAltitude 1 1.08368 29.586 -401.56 ## ## Step: AIC=-409.29 ## pH ~ SDI + fForested + logAltitude + fForested:logAltitude ## ## Df Sum of Sq RSS AIC ## &lt;none&gt; 28.517 -409.29 ## - fForested:logAltitude 1 1.2837 29.801 -402.04 ## - SDI 1 29.3674 57.884 -262.62 ## ## Call: ## lm(formula = pH ~ SDI + fForested + logAltitude + fForested:logAltitude, ## data = iph) ## ## Coefficients: ## (Intercept) SDI fForestedyes ## 8.10382 -0.02461 1.29402 ## logAltitude fForestedyes:logAltitude ## 0.07944 -0.28647 AICが最小のモデルは以下の通り。 m2_3 &lt;- lm(pH ~ SDI + logAltitude*fForested, data = iph) 1.2.4 Model validation 1.2.4.1 Check homogeinity and model misfit 標準化残差と予測値、各共変量の関係は特にパターンが見られず、問題ないよう。 resid &lt;- rstandard(m2_3) data.frame(resid = resid, fitted = predict(m2_3)) %&gt;% ggplot(aes(x = fitted, y = resid))+ geom_point(shape = 1)+ theme_bw()+ theme(aspect.ratio = 1)+ geom_hline(yintercept = 0, linetype = &quot;dashed&quot;) iph %&gt;% mutate(resid = resid) %&gt;% select(resid, SDI, logAltitude) %&gt;% pivot_longer(cols = c(SDI, logAltitude)) %&gt;% ggplot(aes(x = value, y = resid))+ geom_point(shape = 1)+ geom_hline(yintercept = 0, linetype = &quot;dashed&quot;)+ theme_bw()+ theme(aspect.ratio = 1)+ facet_rep_wrap(~ name, repeat.tick.labels = TRUE, scales = &quot;free&quot;)+ theme_bw()+ labs(x = &quot;&quot;) iph %&gt;% mutate(resid = resid) %&gt;% select(resid, fForested) %&gt;% ggplot(aes(x = fForested, y = resid))+ geom_boxplot()+ theme_bw()+ theme(aspect.ratio = 1) 1.2.5 Check spatial dependence 地理的空間上に残差を図示してもパターンがあるかはわかりにくい。 iph %&gt;% mutate(resid = resid) %&gt;% ggplot(aes(x = Easting, y = Northing))+ geom_point(shape = 21, aes(fill = resid &gt;= 0, size = abs(resid)))+ scale_fill_manual(values = c(&quot;white&quot;,&quot;black&quot;))+ theme_bw()+ theme(aspect.ratio = 1) 図1.4: Residuals plotted versus spatial position. The width of a point is proportional to the (absolute) value of a residual. Filled circles are positive residuals and open circles are negative residuals. It would be useful to add the contour lines of the Irish borders. そこで、バリオグラムを作成する。 バリオグラムではまず、データ間の距離がある特定の範囲内にあるデータのペアを抽出する。例えば、図1.5は10kmずつに区切った範囲内にある2つのデータをつないだものである。そのうえで、ある距離範囲カテゴリ(e.g., 10km &lt; dist &lt; 20km)において各データペアの残差の差の二乗を平均したものを算出する。これを全距離範囲カテゴリについて行い、それを図示したものをバリオグラムという。なお、各範囲カテゴリには、少なくとも100ペアくらいはあった方がよい。 crossing(ID1 = iph$ID, ID2 = iph$ID) %&gt;% left_join(iph %&gt;% select(ID,Easting, Northing), by = c(&quot;ID1&quot; = &quot;ID&quot;)) %&gt;% rename(Easting1 = Easting, Northing1 = Northing) %&gt;% left_join(iph %&gt;% select(ID,Easting, Northing), by = c(&quot;ID2&quot; = &quot;ID&quot;)) %&gt;% rename(Easting2 = Easting, Northing2 = Northing) %&gt;% filter(ID1 != ID2) %&gt;% mutate(dist = sqrt((Easting1 - Easting2)^2 + (Northing1 - Northing2)^2)/1000) %&gt;% mutate(cat = ifelse(dist &lt; 10, &quot;Distances &lt; 10 km&quot;, ifelse(dist &lt; 20, &quot;10 km &lt; Distances &lt; 20 km&quot;, ifelse(dist &lt; 30, &quot;20 km &lt; Distances &lt; 30 km&quot;, ifelse(dist &lt; 40, &quot;30 km &lt; Distances &lt; 40 km&quot;, &quot;NA&quot;))))) %&gt;% mutate(cat2 = ifelse(dist &lt; 40, 1, ifelse(dist &lt; 30, 2, ifelse(dist &lt; 20, 3, ifelse(dist &lt; 10, 4, &quot;NA&quot;))))) %&gt;% filter(cat != &quot;NA&quot;) %&gt;% mutate(cat = fct_relevel(cat, &quot;Distances &lt; 10 km&quot;)) %&gt;% ggplot()+ geom_segment(aes(x = Easting1, xend = Easting2, y = Northing1, yend = Northing2), data = . %&gt;% filter(cat2 == &quot;1&quot;))+ geom_segment(aes(x = Easting1, xend = Easting2, y = Northing1, yend = Northing2), data = . %&gt;% filter(cat2 == &quot;2&quot;))+ geom_segment(aes(x = Easting1, xend = Easting2, y = Northing1, yend = Northing2), data = . %&gt;% filter(cat2 == &quot;3&quot;))+ geom_segment(aes(x = Easting1, xend = Easting2, y = Northing1, yend = Northing2), data = . %&gt;% filter(cat2 == &quot;4&quot;))+ facet_rep_wrap(~cat, repeat.tick.labels = TRUE)+ theme_bw()+ theme(aspect.ratio = 1)+ labs(x = &quot;Easting&quot;, y = &quot;Northing&quot;) 図1.5: Each panel shows c ombinations of any two sampling locations with distances of certain threshold values. もしデータに空間的な相関がないのであれば、距離の範囲カテゴリに関わらずデータペアの残差の差の平均は一定になるはずである(= バリオグラムはx軸と平行になる)。一方で、例えば空間的に近いデータほど似た残差をとるのであれば、近い距離範囲カテゴリではデータペアの残差の差の平均が小さくなる。 Rでは以下のように実行できる。cressie = TRUEとすることで推定がより頑強になり、外れ値の影響を小さくすることができる。npは各距離範囲カテゴリのデータ数を、distはそれぞれの距離カテゴリーにおけるデータ間の平均距離、gammaは計算されたバリオグラムの値を表す。明らかにプロットは一定の値をとっておらず、強い空間相関があることが予想される(図??)。 vario_2_3 &lt;- data.frame(resid = rstandard(m2_3), Easting.km = iph$Easting/1000, Northing.km = iph$Northing/1000) sp::coordinates(vario_2_3) &lt;- c(&quot;Easting.km&quot;, &quot;Northing.km&quot;) vario_2_3 %&gt;% variogram(resid ~ 1, data = ., cressie = TRUE, ## 距離が150km以下のデータのみ使用 cutoff = 150, ## 各距離範囲カテゴリの範囲 width = 10) %&gt;% ggplot(aes(x = dist, y = gamma))+ geom_point(aes(size = np))+ theme_bw()+ theme(aspect.ratio = 1)+ labs(y = &quot;semivariogram&quot;) 南北方向と東西方向の距離を分けて調べることもできる。特に東西方向では明確にバリオグラムが水平ではなく、空間的な独立性がないことが分かる。 vario_2_3 %&gt;% variogram(resid ~ Easting.km + Northing.km, data = ., ## 0が南北方向、90が東西方向 alpha = c(0, 90), cressie = TRUE, cutoff = 150, width = 10) %&gt;% ggplot(aes(x = dist, y = gamma))+ geom_point(aes(size = np))+ theme_bw()+ theme(aspect.ratio = 1)+ facet_rep_wrap(~ dir.hor, labeller = as_labeller(c(&quot;0&quot; = &quot;North-South&quot;, &quot;90&quot; = &quot;East-West&quot;)))+ labs(y = &quot;semivariogram&quot;) 1.3 GAM applied to temporal data 1.3.1 Subnivium temperature data 本節では、 Petty et al. (2015) のデータを用いる。この論文では雪下と地面の間の環境(subnivium)の温度を調べている。積雪量が温度に与える影響を、米ウィスコンシン州の3か所の3つの異なる環境(tall grass prailies, deciduous, coniferous)で検討している。 2013年12月から2014年3月における、日ごとの平均温度が記録されている。各環境に4つずつデータロガーが置かれている。そのため、\\(3 \\times 4 = 12\\)個の時系列データがある。 sn &lt;- read_csv(&quot;data/Snow.csv&quot;) %&gt;% mutate(date = as_datetime(str_c(Year,Month, Day, sep = &quot;-&quot;))) %&gt;% mutate(date_num = as.numeric((date - min(date))/(3600*24)) + 1) datatable(sn, options = list(scrollX = 20), filter = &quot;top&quot;) 論文に倣い、2013年12月5日から2014年3月3日までのデータを用いる(4 &lt;= date_num &lt;= 92)。 sn2 &lt;- sn %&gt;% filter(date_num &gt;= 4 &amp; date_num &lt;= 92) 各環境における温度の変化は以下の通り。 sn2 %&gt;% ggplot(aes(x = date_num, y = Temp))+ geom_line(aes(linetype = Logger))+ facet_rep_wrap(~Type)+ theme_bw()+ theme(aspect.ratio = 1.2) 1.3.2 Sources of dependency 同じ環境のロガーはそれぞれ10mしか離れていないので、同じ日におけるこれらのロガーのデータは独立ではない。また、同じロガーのデータについても、時間的な相関があると考えられる(t-1日目の温度とt日目の温度が独立とは考えにくい)。各環境間は距離が離れているので、独立性があると仮定してよさそう。 以下では、こうした非独立性を考慮せずに分析をした場合にどのような問題がが生じるかを見ていく。 1.3.3 The model 以下のGAMMを適用する(回帰係数は省略している)。ロガーIDをランダム切片として入れている。環境ごとにsmootherを推定する。\\(t\\)は経過日数(date_num)、\\(i\\)はロガーのidを表す。 \\[ \\begin{aligned} T_{it} &amp;\\sim N(\\mu_t, \\sigma^2)\\\\ \\mu_{it} &amp;= \\alpha + f_j(date\\_num_t) + Type_i + a_i\\\\ a_i &amp;\\sim N(0, \\sigma_{Logger}^2) \\end{aligned} (\\#eq:m2.4) \\] Rでは以下のように実行する。 m2_4 &lt;- gamm(Temp ~ s(date_num, by = Type) + Type, random = list(Logger =~ 1), data = sn2 %&gt;% mutate(Type = as.factor(Type))) 結果は以下の通り。 summary(m2_4$gam) ## ## Family: gaussian ## Link function: identity ## ## Formula: ## Temp ~ s(date_num, by = Type) + Type ## ## Parametric coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) -1.7363 0.1796 -9.670 &lt;2e-16 *** ## TypeDeciduous -0.1378 0.2574 -0.535 0.5927 ## TypePrairie 0.5000 0.2551 1.960 0.0503 . ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Approximate significance of smooth terms: ## edf Ref.df F p-value ## s(date_num):TypeConiferous 8.658 8.658 36.21 &lt;2e-16 *** ## s(date_num):TypeDeciduous 8.205 8.205 62.67 &lt;2e-16 *** ## s(date_num):TypePrairie 8.229 8.229 37.69 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## R-sq.(adj) = 0.548 ## Scale est. = 1.0144 n = 921 summary(m2_4$lme) ## Linear mixed-effects model fit by maximum likelihood ## Data: strip.offset(mf) ## AIC BIC logLik ## 2787.212 2840.292 -1382.606 ## ## Random effects: ## Formula: ~Xr - 1 | g ## Structure: pdIdnot ## Xr1 Xr2 Xr3 Xr4 Xr5 Xr6 Xr7 Xr8 ## StdDev: 20.28316 20.28316 20.28316 20.28316 20.28316 20.28316 20.28316 20.28316 ## ## Formula: ~Xr.0 - 1 | g.0 %in% g ## Structure: pdIdnot ## Xr.01 Xr.02 Xr.03 Xr.04 Xr.05 Xr.06 Xr.07 Xr.08 ## StdDev: 16.03337 16.03337 16.03337 16.03337 16.03337 16.03337 16.03337 16.03337 ## ## Formula: ~Xr.1 - 1 | g.1 %in% g.0 %in% g ## Structure: pdIdnot ## Xr.11 Xr.12 Xr.13 Xr.14 Xr.15 Xr.16 Xr.17 Xr.18 ## StdDev: 14.19846 14.19846 14.19846 14.19846 14.19846 14.19846 14.19846 14.19846 ## ## Formula: ~1 | Logger %in% g.1 %in% g.0 %in% g ## (Intercept) Residual ## StdDev: 0.3414393 1.007198 ## ## Fixed effects: y ~ X - 1 ## Value Std.Error DF t-value p-value ## X(Intercept) -1.736302 0.1798447 906 -9.654451 0.0000 ## XTypeDeciduous -0.137767 0.2578500 9 -0.534292 0.6061 ## XTypePrairie 0.499994 0.2555270 9 1.956717 0.0821 ## Xs(date_num):TypeConiferousFx1 -1.238174 1.0476349 906 -1.181875 0.2376 ## Xs(date_num):TypeDeciduousFx1 3.652453 1.4161295 906 2.579180 0.0101 ## Xs(date_num):TypePrairieFx1 0.042635 1.1659387 906 0.036567 0.9708 ## Correlation: ## X(Int) XTypDc XTypPr X(_):TC X(_):TD ## XTypeDeciduous -0.697 ## XTypePrairie -0.704 0.491 ## Xs(date_num):TypeConiferousFx1 -0.001 0.001 0.001 ## Xs(date_num):TypeDeciduousFx1 0.000 0.004 0.000 0.000 ## Xs(date_num):TypePrairieFx1 0.000 0.000 0.001 0.000 0.000 ## ## Standardized Within-Group Residuals: ## Min Q1 Med Q3 Max ## -5.0136973 -0.4288093 0.0765251 0.5515962 3.2003331 ## ## Number of Observations: 921 ## Number of Groups: ## g g.0 %in% g ## 1 1 ## g.1 %in% g.0 %in% g Logger %in% g.1 %in% g.0 %in% g ## 1 12 1.3.4 Model validation ロガーごとの標準化残差を時系列的に図示したのが下図である。ここからパターンを読み取るのは難しい。 sn2 %&gt;% mutate(resid = resid(m2_4$lme, type = &quot;n&quot;)) %&gt;% ggplot(aes(x = date_num, y = resid))+ geom_point()+ geom_smooth(color = &quot;grey23&quot;)+ facet_rep_wrap(~Logger, scales = &quot;free_y&quot;) 時系列相関があるかを調べるためには、自己相関関数(acf)を描くことが有効である。自己相関関数は、k時点前のデータとの相関をkの関数としてあらわしたものである。 以下で、ロガーごとに時系列相関を算出する。 sn2 %&gt;% mutate(resid = resid(m2_4$lme, type = &quot;n&quot;)) %&gt;% group_by(Logger) %&gt;% arrange(date_num, .by_group = TRUE) -&gt; sn3 Loggerid &lt;- unique(sn3$Logger) all.out &lt;- NULL for(i in seq_along(Loggerid)){ data &lt;- sn3 %&gt;% filter(Logger == Loggerid[i]) ## 各ロガーについて時系列相関を算出 out.acf &lt;- acf(data$resid, lag.max = 15, plot = FALSE) ## 出力をデータフレームに out.df &lt;- data.frame(Timelag = out.acf$lag, Acf = out.acf$acf, SE = qnorm(0.975)/sqrt(out.acf$n.used), ID = Loggerid[i]) ## 全て結合 all.out &lt;- bind_rows(all.out, out.df) } 図示したのが下図である。グレーの塗りつぶしは95%信頼区間を表している。図から、全てのロガーにおいて1時点前のデータとの相関が高いことが示唆される。これは、残差に時系列相関があることを示しており、これを考慮したモデルを作成する必要性を示唆している。 all.out %&gt;% ggplot(aes(x = Timelag, y = 0))+ geom_segment(aes(xend = Timelag, yend = Acf))+ geom_ribbon(aes(ymax = SE, ymin = -SE), alpha = 0.3)+ theme_bw()+ theme(aspect.ratio = 0.8)+ facet_rep_wrap(~ID, repeat.tick.labels = TRUE)+ labs(y = &quot;Auto-correlation&quot;) acfの代わりにバリオグラムを用いることもできる。これは、時間間隔が一定でない場合などに有効である。これについては後でもう一度触れる。 References "],["Chapter3.html", "2 Time series and GLS 2.1 Ospreys 2.2 Covariance and correlation coefficients 2.3 Linear regression models 2.4 Focusing on the residual covariance matrix 2.5 Dependency and the covariance matrix 2.6 Dealing with temporal dependency 2.7 Multiple time series", " 2 Time series and GLS 本章では、時系列データに対して用いることができる回帰モデルについて解説する。 2.1 Ospreys Steidl et al. (1991) は、ミサゴの卵の厚さが殺虫剤の崩壊産物(DDD)によって変わるかを調べ、有意な関連を見つけた。本節ではこのデータを用いる。 osp &lt;- read_csv(&quot;data/Ospreys.csv&quot;) datatable(osp, options = list(scrollX = 20), filter = &quot;top&quot;) 2.2 Covariance and correlation coefficients DDDと卵の殻の厚さの関連は以下の通り。 osp %&gt;% ggplot(aes(x = DDD, y = THICK))+ geom_point(shape = 1, size = 2)+ theme_bw()+ theme(aspect.ratio=1) 相関係数は-0.42である。 cor(osp$THICK, osp$DDD) ## [1] -0.4195692 2.3 Linear regression models 以下のモデルを考える。 \\[ \\begin{aligned} Thichness_i &amp;= \\beta_1 + \\beta_2 \\times DDD_i + \\epsilon_i \\\\ \\epsilon_i &amp;\\sim N(0, \\sigma^2) \\end{aligned} \\] Rでは以下のように実行する。 m3_1 &lt;- lm(THICK ~ DDD, data = osp) 2.4 Focusing on the residual covariance matrix 残差\\(\\epsilon_i\\)は行列式で以下のように書ける。なお、\\(\\bf{I}\\)は単位行列である。 \\[ \\bf{\\epsilon} \\sim N(0, \\bf{\\sigma^2} \\times \\mathbf{I}) \\] より一般的に、残差\\(\\epsilon_i\\)は以下のように書ける。\\(\\bf{\\Sigma}\\)は分散共分散行列と呼ばれる。 \\[ \\bf{\\epsilon} \\sim N(0, \\bf{\\Sigma}) \\] 通常の線形回帰モデルでは、\\(\\bf{\\Sigma}\\)は以下のようになる。ここで、\\(sigma^2\\)に単位行列を書けるということは、残差間が独立であることを仮定していることになる。例えば、1行2列目は\\(\\epsilon_1\\)と\\(\\epsilon_2\\)の共分散を表すが、単位行列ではこれが0になる。同様に、単位行列は対角成分以外が全て0になるので、異なる残差同士の共分散が全て0になると仮定していることになる。 \\[ \\bf{\\Sigma} = \\sigma^2 \\times \\mathbf{I} \\] より一般的には、分散共分散行列\\(\\bf{\\Sigma}\\)は以下のように書ける。これは対称行列である。\\(\\phi_{i,j}\\)は\\(\\epsilon_i\\)と\\(\\epsilon_j\\)の共分散である。通常の回帰分析ではこれらが全て0と仮定された。共分散が０以外の値をとる場合、異なる残差は独立ではなくなる。 \\[ \\bf{\\Sigma} = \\begin{pmatrix} \\sigma^2 &amp; \\phi_{1,2} &amp; \\phi_{1,3} &amp; \\phi_{1,4} &amp; \\cdots &amp;\\phi_{1,25} \\\\ &amp; \\sigma^2 &amp; \\phi_{2,3} &amp; \\phi_{2,4} &amp; \\cdots&amp; \\phi_{2,25}\\\\ &amp; &amp; \\sigma^2 &amp; \\phi_{3,4} &amp; \\cdots &amp; \\phi_{3,25} \\\\ &amp; &amp; &amp; \\sigma^2 &amp; \\ddots &amp; \\vdots \\\\ &amp; &amp; &amp; &amp; \\sigma^2 &amp; \\phi_{24,25}\\\\ &amp; &amp; &amp; &amp; &amp; \\sigma^2 \\end{pmatrix} \\tag{2.1} \\] 2.5 Dependency and the covariance matrix ここで、回帰モデルにおける分散共分散行列の役割について理解するためにシミュレーションを行う。変数\\(z_1\\)と\\(z_2\\)が以下に従って1000個ずつ得られるとする。 \\[ \\begin{aligned} z_1 &amp;\\sim N(10,1)\\\\ z_2 &amp;\\sim N(15,1) \\end{aligned} \\] Rでは以下のように得る。 set.seed(1234) z1 &lt;- rnorm(1000, 10, 1) z2 &lt;- rnorm(1000, 15, 1) MASSパッケージのmvrnorm関数を用い、多変量正規分布から同様に値を行列として得ることもできる。 sigma &lt;- diag(2) Z &lt;- mvrnorm(1000, mu = c(10, 15), Sigma = sigma) %&gt;% data.frame() %&gt;% rename(z1 = 1, z2 = 2) datatable(Z) このとき、\\(z_1\\)と\\(z_2\\)は行列を用いると以下のように多変量正規分布から得られていると書くことができる。これは、平均がそれぞれ10と15で、分散共分散行列\\(\\bf{\\Sigma}\\)が単位行列の多変量正規分布から値が得られたことを示す。 \\[ \\begin{pmatrix} z_1 \\\\ z_2 \\end{pmatrix} = N \\Bigl( \\begin{pmatrix} 10 \\\\ 15 \\end{pmatrix}, \\begin{pmatrix} 1 &amp; 0 \\\\ 0 &amp; 1 \\\\ \\end{pmatrix} \\Bigl) \\] 得られたデータをプロットして分かるように、分散共分散行列が単位行列であり、\\(z_1\\)と\\(z_2\\)の間の共分散はゼロとなっているため、これらに相関が全くないことが分かる。 Z %&gt;% ggplot(aes(x = z1, y = z2))+ geom_point(shape = 1, size = 2)+ theme_bw()+ theme(aspect.ratio = 1) 今度は、\\(z_1\\)と\\(z_2\\)が正の相関を持つような場合を考える。このようなときは、以下のように\\(\\bf{\\Sigma}\\)の\\(\\phi\\)成分を0でなく正の値にしてやればよい(ここでは0.9)。分散を1にしているので、この値はそのまま相関係数になる。 sigma &lt;- diag(2) sigma[1,2] &lt;- 0.9 sigma[2,1] &lt;- 0.9 sigma ## [,1] [,2] ## [1,] 1.0 0.9 ## [2,] 0.9 1.0 実際に得られた値をプロットしても、\\(z_1\\)と\\(z_2\\)が強い相関を持つことが分かる。このように、\\(\\bf{Sigma}\\)の非対角成分に0以外の値を割り当てることで、多変量正規分布から得られる値が非独立であることを表現できる。 Z &lt;- mvrnorm(1000, mu = c(10, 15), Sigma = sigma) %&gt;% data.frame() %&gt;% rename(z1 = 1, z2 = 2) Z %&gt;% ggplot(aes(x = z1, y = z2))+ geom_point(shape = 1, size = 2)+ theme_bw()+ theme(aspect.ratio = 1) 2.6 Dealing with temporal dependency 同様に、時系列データに対しても、残差の分散共分散行列の非対角成分\\(\\phi_{i,j}\\)を0以外の値にすることで、データの非独立性に対処することができる。そのような方法の一つがGLS(Generalized least square)と呼ばれる方法である。 2.6.1 Adelie penguins ここでは、 Barbraud and Weimerskirch (2006) が南極の海鳥が到着する日と産卵日について調査したデータを用いる。ここでは、特に産卵日について着目する。 データは以下の通り。各年について1つのデータがある。 bird &lt;- read_csv(&quot;data/Phenology_Data_Antarcticbirds_AFZ1.csv&quot;) datatable(bird, options = list(scrollX = 20), filter = &quot;top&quot;) 分析では、海氷面積によって産卵日に違いが出るかを調べる。海氷面積の直接的なデータはないので、その近似として海中のメタルスルホン酸(MSA: 海氷が多いと多くなる)を用いる。 産卵日の年変動と、MSAと産卵日の関係は以下のようになる。 bird %&gt;% ggplot(aes(x = Year, y = LayingAP))+ geom_line()+ geom_point()+ theme_bw()+ theme(aspect.ratio = 0.7)+ labs(y = &quot;Laying date&quot;) -&gt; p1 bird %&gt;% ggplot(aes(x = MSA, y = LayingAP))+ geom_point(shape = 1, size = 2)+ theme_bw()+ theme(aspect.ratio = 1)+ labs(y = &quot;Laying date&quot;) -&gt; p2 p1 + p2 2.6.2 Do we have dependency? 産卵日に影響する様々な要因(成熟したメスの数、病気の流行、ホルモンレベル)などは年ごとに独立ではなく、t年のデータがt+1年のデータに影響を及ぼしていると考えられる。よって、各年の産卵日は独立ではないと考えられる。 2.6.3 Formulation of the linear regression model まずは時系列を考慮しない通常の線形回帰モデルを適用する。モデル式は以下の通り。 \\[ \\begin{aligned} LD_t &amp;= \\beta_1 + \\beta_2 \\times MSA_t + \\epsilon_t \\\\ \\epsilon_t &amp;\\sim N(0,\\sigma^2) \\end{aligned} \\] 2.6.4 Application of the linear regression model Rでは以下のように実行する。ここでは、nlmeパッケージのgls関数を用いる(もちろん、lm関数でも実行できる)。 m3_2a &lt;- gls(LayingAP ~ MSA, data = bird, na.action = na.omit) 結果は以下の通り。MSAの効果は弱いことが分かる。 summary(m3_2a) ## Generalized least squares fit by REML ## Model: LayingAP ~ MSA ## Data: bird ## AIC BIC logLik ## 139.7118 144.0137 -66.85588 ## ## Coefficients: ## Value Std.Error t-value p-value ## (Intercept) 247.91825 1.25111 198.15867 0.0000 ## MSA -33.01513 16.42976 -2.00947 0.0533 ## ## Correlation: ## (Intr) ## MSA -0.956 ## ## Standardized residuals: ## Min Q1 Med Q3 Max ## -1.5831272 -0.5845941 -0.1200808 0.5813974 1.9238887 ## ## Residual standard error: 2.111689 ## Degrees of freedom: 33 total; 31 residual モデルの標準化残差と予測値、MSAとの関連をプロットしたのが以下の図である。数字は観察年の下２桁を表す。明確なパターンは見当たらない。しかし、よく見てみると観察年が近いと似た残差をとる傾向があるように思える。例えば、60年代のデータは全て残差が負の値になっている。 data.frame(resid = resid(m3_2a, type = &quot;n&quot;), Year = bird %&gt;% drop_na(LayingAP, MSA) %&gt;% .$Year, fitted = predict(m3_2a), MSA = bird %&gt;% drop_na(LayingAP, MSA) %&gt;% .$Year) %&gt;% mutate(Year2 = str_sub(Year, 3,4)) -&gt; fitted_m3_2a fitted_m3_2a %&gt;% ggplot(aes(x = fitted, y = resid))+ geom_point(shape = 1, size = 2)+ geom_text_repel(aes(label = Year2))+ geom_hline(yintercept = 0, linetype = &quot;dashed&quot;)+ theme_bw(base_size = 14)+ theme(aspect.ratio = 1) -&gt; p1 fitted_m3_2a %&gt;% ggplot(aes(x = MSA, y = resid))+ geom_point(shape = 1, size = 2)+ geom_text_repel(aes(label = Year2))+ geom_hline(yintercept = 0, linetype = &quot;dashed&quot;)+ theme_bw(base_size = 14)+ theme(aspect.ratio = 1) -&gt; p2 p1 + p2 自己相関関数をプロットしてみると、あまり明確にはわからないが有意に自己相関が高いところがあることが分かる。 resid &lt;- rep(NA, nrow(bird)) i &lt;- !is.na(bird$LayingAP) &amp; !is.na(bird$MSA) resid[i] &lt;- resid(m3_2a, type = &quot;n&quot;) acf &lt;- acf(resid, lag.max = 20, na.action = na.pass, plot = FALSE) data.frame(lag = 0:20, acf = acf$acf, SE = qnorm(0.975)/sqrt(acf$n.used)) %&gt;% ggplot(aes(x = lag, y = 0))+ geom_segment(aes(xend = lag, yend = acf))+ geom_hline(aes(yintercept = -SE), linetype = &quot;dashed&quot;, color = &quot;navy&quot;)+ geom_hline(aes(yintercept = SE), linetype = &quot;dashed&quot;, color = &quot;navy&quot;)+ theme_bw()+ labs(y = &quot;acf&quot;)+ theme(aspect.ratio = 1)+ scale_x_continuous(breaks = seq(0,20,1)) 欠損値が多いので、バリオグラムで見た方が適切かもしれない。バリオグラムは以下のようになる。バリオグラムは水平にならず、やはり残差に時間的な相関があることが示唆される。 vario_3_2a &lt;- data.frame(resid = resid, Year = bird$Year, zero = 0) %&gt;% drop_na() sp::coordinates(vario_3_2a) &lt;- c(&quot;Year&quot;, &quot;zero&quot;) vario_3_2a %&gt;% variogram(resid ~ 1, data = ., cutoff = 9, width = 1) %&gt;% ggplot(aes(x = dist, y = gamma))+ geom_line()+ geom_point(size = 3, shape = 21, fill = &quot;black&quot;, color = &quot;white&quot;, stroke = 2)+ theme_bw(base_size = 14)+ theme(aspect.ratio = 1)+ labs(y = &quot;semivariogram&quot;, x = &quot;Time lag&quot;)+ coord_cartesian(ylim = c(0,1.4))+ scale_x_continuous(breaks = seq(1,9,1))+ scale_y_continuous(breaks = seq(0,1.4,0.2)) こうした時系列相関が問題になりうるかを判断するためには、時系列相関を考慮したモデルを作成し、それを考慮しないモデルと比較する必要がある。 2.6.5 Formulation of the GLS model 通常の回帰モデルでは異なる残差同士が独立(相関が0)なので、以下のように書くことができる。 \\[ \\begin{aligned} LD_t &amp;= \\beta_1 + \\beta_2 \\times MSA_t + \\epsilon_t \\\\ \\epsilon_t &amp;\\sim N(0,\\sigma^2)\\\\ cor(\\epsilon_t, \\epsilon_s) &amp;= \\begin{cases} 0 \\; \\bf{if} \\;t \\neq s \\\\ 1 \\; \\bf{if} \\;t = s \\end{cases} \\end{aligned} \\] これまでに見てきたように、時系列相関を考慮するためには異なる残差同士の相関が0でないと仮定すればよい。これは、以下のように書ける。なお、\\(h()\\)は残差同士の相関を決める関数で\\(\\phi\\)はその関数におけるパラメータである。 \\[ \\begin{aligned} LD_t &amp;= \\beta_1 + \\beta_2 \\times MSA_t + \\epsilon_t \\\\ \\epsilon_t &amp;\\sim N(0,\\sigma^2)\\\\ cor(\\epsilon_t, \\epsilon_s) &amp;= h(\\phi, \\epsilon_t, \\epsilon_s) \\end{aligned} \\] 時系列相関を考慮したモデルでは、この\\(h()\\)に様々な関数を想定することで、データの非独立性に対応する。最も一般的なものは、AR1過程と呼ばれるもので、以下のように書ける。なお、\\(\\phi\\)は0から1の値をとる。 \\[ \\begin{aligned} \\epsilon_t &amp;= \\phi \\times \\epsilon_{t-1} + \\nu_t \\\\ \\nu_t &amp;\\sim N(0, \\sigma_\\nu^2) \\end{aligned} \\] 関数\\(h()\\)は以下のように書ける。このとき、残差は定常性を持つといわれる。これは、残差の共分散は時間差のみに依存しているということである。 \\[ h(\\phi, \\epsilon_t, \\epsilon_s) = \\phi^{|t-s|} \\] AR1で残差の分散共分散行列\\(\\bf{\\Sigma}\\)は以下のように書ける。行列中のパラメータは$$1つなので、これさえ推定できれば良い。 \\[ \\bf{\\Sigma} = cov(\\bf{\\epsilon}) = \\frac{\\sigma_{\\nu}^2}{1-\\phi^2} \\times \\begin{pmatrix} 1 &amp; \\phi &amp; \\phi^2 &amp; \\phi^3 &amp; \\cdots &amp; \\phi^{54} \\\\ \\phi &amp; 1 &amp; \\phi &amp; \\phi^2 &amp; \\ddots &amp; \\vdots\\\\ \\phi^2 &amp; \\phi &amp; \\ddots &amp; \\ddots &amp; \\ddots &amp; \\phi^3 \\\\ \\phi^3 &amp; \\phi^2 &amp; \\ddots &amp; \\ddots &amp; \\ddots &amp; \\phi^2 \\\\ \\vdots &amp; \\ddots &amp; \\ddots &amp; \\phi &amp; 1 &amp; \\phi \\\\ \\phi^{54} &amp; \\cdots &amp; \\phi^2 &amp; \\phi^2 &amp; \\phi &amp; 1 \\end{pmatrix} \\] 相関行列は以下のように書ける。 \\[ cor(\\bf{\\epsilon}) = \\begin{pmatrix} 1 &amp; \\phi &amp; \\phi^2 &amp; \\phi^3 &amp; \\cdots &amp; \\phi^{54} \\\\ \\phi &amp; 1 &amp; \\phi &amp; \\phi^2 &amp; \\ddots &amp; \\vdots\\\\ \\phi^2 &amp; \\phi &amp; \\ddots &amp; \\ddots &amp; \\ddots &amp; \\phi^3 \\\\ \\phi^3 &amp; \\phi^2 &amp; \\ddots &amp; \\ddots &amp; \\ddots &amp; \\phi^2 \\\\ \\vdots &amp; \\ddots &amp; \\ddots &amp; \\phi &amp; 1 &amp; \\phi \\\\ \\phi^{54} &amp; \\cdots &amp; \\phi^3 &amp; \\phi^2 &amp; \\phi &amp; 1 \\end{pmatrix} \\] AR1では、回帰係数の推定値とその分散共分散行列は以下のようになる。 \\[ \\begin{aligned} \\bf{\\hat{\\beta}} &amp;= (\\bf{X^t} \\times \\bf{\\Sigma^{-1}} \\times \\bf{X})^{-1} \\times \\bf{X^t} \\times \\bf{\\Sigma^{-1}} \\times \\bf{y}\\\\ cov(\\hat{\\beta}) &amp;= (\\bf{X^t} \\times \\bf{\\Sigma^{-1}} \\times \\bf{X})^{-1} \\end{aligned} \\] AR1過程モデルの代わりに、残差が他の相関構造をもつものを仮定することもできる。例えば、交換可能(exchangable)な相関を持つ場合、相関行列は以下のように書ける。これは、時間差に依らず全ての異なる残差が同じ相関\\(\\phi\\)を持つことを仮定している。これは、短い時系列を持つデータに対しては有効である場合がある。 \\[ cor(\\bf{\\epsilon}) = \\begin{pmatrix} 1 &amp; \\phi &amp; \\phi &amp; \\phi &amp; \\cdots &amp; \\phi \\\\ \\phi &amp; 1 &amp; \\phi &amp; \\phi &amp; \\ddots &amp; \\vdots\\\\ \\phi &amp; \\phi &amp; \\ddots &amp; \\ddots &amp; \\ddots &amp; \\phi\\\\ \\phi &amp; \\phi &amp; \\ddots &amp; \\ddots &amp; \\ddots &amp; \\phi\\\\ \\vdots &amp; \\ddots &amp; \\ddots &amp; \\phi &amp; 1 &amp; \\phi \\\\ \\phi &amp; \\cdots &amp; \\phi &amp; \\phi &amp; \\phi &amp; 1 \\\\ \\end{pmatrix} \\] 2.6.6 Implementation using the gls function AR1モデルのGLSのモデル式を書くと以下のようになる。 \\[ \\begin{aligned} LD_t &amp;= \\beta_1 + \\beta_2 \\times MSA_t + \\epsilon_t \\\\ \\epsilon_t &amp;\\sim N(0,\\sigma^2)\\\\ cor(\\epsilon_t, \\epsilon_s) &amp;= \\phi^{|t-s|} \\end{aligned} \\] Rでは以下のように実行できる。gls関数では、correlation =オプションで様々な残差の相関構造をモデリングできる。例えば、交換可能な相関の場合は、correlation = corCompSymm()とする。 m3_2b &lt;- gls(LayingAP ~ MSA, correlation = corAR1(form = ~Year), data = bird, na.action = na.omit) 結果は以下の通り。推定された\\(phi\\)は0.523である。驚くべきことに、時系列相関を考慮しない場合にはMSAの係数が負の値だったのに対して、今回は正の値になっている。 summary(m3_2b) ## Generalized least squares fit by REML ## Model: LayingAP ~ MSA ## Data: bird ## AIC BIC logLik ## 138.8594 144.5953 -65.42968 ## ## Correlation Structure: ARMA(1,0) ## Formula: ~Year ## Parameter estimate(s): ## Phi1 ## 0.5236874 ## ## Coefficients: ## Value Std.Error t-value p-value ## (Intercept) 244.57591 1.443356 169.44949 0.000 ## MSA 10.33068 17.311974 0.59674 0.555 ## ## Correlation: ## (Intr) ## MSA -0.896 ## ## Standardized residuals: ## Min Q1 Med Q3 Max ## -1.5300255 -0.6243847 -0.0438220 0.7957452 2.0484887 ## ## Residual standard error: 2.345265 ## Degrees of freedom: 33 total; 31 residual モデルの予測値を図示したのが下図である。AR1モデルでは傾きが正になり、MSAと産卵日の関連はより小さなものと推定されている。 nd &lt;- data.frame(MSA =seq(0.03,0.14,length = 100)) data.frame(m3_2a = predict(m3_2a, newdata = nd), m3_2b = predict(m3_2b, newdata = nd), MSA = nd$MSA) %&gt;% pivot_longer(cols = 1:2, names_to = &quot;model&quot;, values_to = &quot;fitted&quot;) %&gt;% ggplot(aes(x = MSA, y = fitted))+ geom_line(aes(color = model), linewidth = 1)+ geom_text(aes(label = str_sub(bird$Year, 3,4), y = LayingAP), data = bird)+ theme_bw()+ theme(aspect.ratio = 0.9)+ scale_color_nejm()+ labs(y = &quot;Laying date&quot;) AICを比較しても、AR1モデルの方がわずかに予測がよいことが分かる。 AIC(m3_2a, m3_2b) 2.7 Multiple time series 第1.3節でみた積雪量と雪下温度の関連を調べた Petty et al. (2015) のデータについてもう一度考える。式@ref(eq:m2.4)のモデルでは、各時系列の残差が自己相関を持っていた。そこで、以下のモデルを考える(回帰係数は省略)。 \\[ \\begin{aligned} &amp;T_{it} = \\alpha + f_j(date\\_num_t) + Type_i + a_i + \\epsilon_{it}\\\\ &amp;a_i \\sim N(0, \\sigma_{Logger}^2)\\\\ &amp;\\epsilon_{it} \\sim N(0, \\sigma^2)\\\\ &amp;cor(\\epsilon_{it}, \\epsilon_{is}) = \\phi^{|t-s|} \\end{aligned} (\\#eq:m3.3) \\] Rでは、以下のように実行できる。ランダム切片を含む場合、自己相関は自動的にそれぞれのロガーに対して適用されるため、correlation = corAR1(form =~date_num)としても同じ結果が得られる。Rのgamm関数では全てのロガーについて同じ\\(\\phi\\)しか推定できない。 m3_3 &lt;- gamm(Temp ~ s(date_num, by = Type) + Type, random = list(Logger =~ 1), correlation = corAR1(form = ~date_num|Logger), data = sn2 %&gt;% mutate(Type = as.factor(Type))) 例えば、ロガー1の残差の相関行列は以下のように書ける。 \\[ \\bf{\\Sigma_1} = cor \\begin{pmatrix} \\epsilon_{1,1}\\\\ \\epsilon_{1,2}\\\\ \\vdots\\\\ \\epsilon_{1,88}\\\\ \\epsilon_{1,89} \\end{pmatrix} = \\begin{pmatrix} 1 &amp; \\phi &amp; \\phi^2 &amp; \\phi^3 &amp; \\cdots &amp; \\phi^{89} \\\\ \\phi &amp; 1 &amp; \\phi &amp; \\phi^2 &amp; \\ddots &amp; \\vdots\\\\ \\phi^2 &amp; \\phi &amp; \\ddots &amp; \\ddots &amp; \\ddots &amp; \\phi^3 \\\\ \\phi^3 &amp; \\phi^2 &amp; \\ddots &amp; \\ddots &amp; \\ddots &amp; \\phi^2 \\\\ \\vdots &amp; \\ddots &amp; \\ddots &amp; \\phi &amp; 1 &amp; \\phi \\\\ \\phi^{89} &amp; \\cdots &amp; \\phi^3 &amp; \\phi^2 &amp; \\phi &amp; 1 \\end{pmatrix} \\] gamm関数で推定した場合、全てのロガーで同じ\\(\\phi\\)が推定されるので、どのロガーの残差の相関行列も\\(\\bf{\\Sigma_1}\\)となる。よって、すべてのロガーの残差の相関行列は以下のように書ける。対角成分以外が0なのは、異なるロガーの残差の相関は0である(= 独立である)ことを表している。 \\[ \\begin{aligned} cor \\begin{pmatrix} \\begin{pmatrix} \\epsilon_{1,1}\\\\ \\vdots\\\\ \\epsilon_{1,89} \\end{pmatrix}\\\\ \\begin{pmatrix} \\epsilon_{2,1}\\\\ \\vdots\\\\ \\epsilon_{2,89} \\end{pmatrix}\\\\ \\vdots \\\\ \\begin{pmatrix} \\epsilon_{12,1}\\\\ \\vdots\\\\ \\epsilon_{12,89} \\end{pmatrix} \\end{pmatrix} = \\begin{pmatrix} \\bf{\\Sigma_1} &amp; 0 &amp; \\cdots &amp; 0\\\\ 0 &amp; \\bf{\\Sigma_2} &amp; \\cdots &amp; 0\\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ 0 &amp; 0 &amp; \\cdots &amp; \\bf{\\Sigma_{12}} \\\\ \\end{pmatrix} = \\begin{pmatrix} \\bf{\\Sigma_1} &amp; 0 &amp; \\cdots &amp; 0\\\\ 0 &amp; \\bf{\\Sigma_1} &amp; \\cdots &amp; 0\\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ 0 &amp; 0 &amp; \\cdots &amp; \\bf{\\Sigma_{1}} \\\\ \\end{pmatrix} \\end{aligned} \\] 結果は以下の通り。\\(\\phi\\)は0.504と推定されている。 summary(m3_3$lme) ## Linear mixed-effects model fit by maximum likelihood ## Data: strip.offset(mf) ## AIC BIC logLik ## 2587.526 2645.432 -1281.763 ## ## Random effects: ## Formula: ~Xr - 1 | g ## Structure: pdIdnot ## Xr1 Xr2 Xr3 Xr4 Xr5 Xr6 Xr7 Xr8 ## StdDev: 16.80172 16.80172 16.80172 16.80172 16.80172 16.80172 16.80172 16.80172 ## ## Formula: ~Xr.0 - 1 | g.0 %in% g ## Structure: pdIdnot ## Xr.01 Xr.02 Xr.03 Xr.04 Xr.05 Xr.06 Xr.07 Xr.08 ## StdDev: 12.99064 12.99064 12.99064 12.99064 12.99064 12.99064 12.99064 12.99064 ## ## Formula: ~Xr.1 - 1 | g.1 %in% g.0 %in% g ## Structure: pdIdnot ## Xr.11 Xr.12 Xr.13 Xr.14 Xr.15 Xr.16 Xr.17 Xr.18 ## StdDev: 10.23867 10.23867 10.23867 10.23867 10.23867 10.23867 10.23867 10.23867 ## ## Formula: ~1 | Logger %in% g.1 %in% g.0 %in% g ## (Intercept) Residual ## StdDev: 0.2900993 1.070964 ## ## Correlation Structure: ARMA(1,0) ## Formula: ~date_num | g/g.0/g.1/Logger ## Parameter estimate(s): ## Phi1 ## 0.5039287 ## Fixed effects: y ~ X - 1 ## Value Std.Error DF t-value p-value ## X(Intercept) -1.7091286 0.1769862 906 -9.656845 0.0000 ## XTypeDeciduous -0.1055758 0.2601888 9 -0.405766 0.6944 ## XTypePrairie 0.5034402 0.2537067 9 1.984339 0.0785 ## Xs(date_num):TypeConiferousFx1 -1.2565046 1.4583432 906 -0.861597 0.3891 ## Xs(date_num):TypeDeciduousFx1 3.0138336 1.7648757 906 1.707675 0.0880 ## Xs(date_num):TypePrairieFx1 0.4391241 1.4170564 906 0.309885 0.7567 ## Correlation: ## X(Int) XTypDc XTypPr X(_):TC X(_):TD ## XTypeDeciduous -0.680 ## XTypePrairie -0.698 0.475 ## Xs(date_num):TypeConiferousFx1 0.006 -0.004 -0.004 ## Xs(date_num):TypeDeciduousFx1 0.000 -0.004 0.000 0.000 ## Xs(date_num):TypePrairieFx1 0.000 0.000 0.001 0.000 0.000 ## ## Standardized Within-Group Residuals: ## Min Q1 Med Q3 Max ## -5.4057668 -0.4121370 0.1026576 0.5351727 2.4662264 ## ## Number of Observations: 921 ## Number of Groups: ## g g.0 %in% g ## 1 1 ## g.1 %in% g.0 %in% g Logger %in% g.1 %in% g.0 %in% g ## 1 12 最後に、モデルの残差の自己相関関数(acf)を図示する。 sn2 %&gt;% mutate(resid = resid(m3_3$lme, type = &quot;n&quot;)) %&gt;% group_by(Logger) %&gt;% arrange(date_num, .by_group = TRUE) -&gt; sn3 Loggerid &lt;- unique(sn3$Logger) all.out &lt;- NULL for(i in seq_along(Loggerid)){ data &lt;- sn3 %&gt;% filter(Logger == Loggerid[i]) ## 各ロガーについて時系列相関を算出 out.acf &lt;- acf(data$resid, lag.max = 15, plot = FALSE) ## 出力をデータフレームに out.df &lt;- data.frame(Timelag = out.acf$lag, Acf = out.acf$acf, SE = qnorm(0.975)/sqrt(out.acf$n.used), ID = Loggerid[i]) ## 全て結合 all.out &lt;- bind_rows(all.out, out.df) } 図示したのが下図である。図からは、依然として多くのロガーでは時系列相関があることが分かる。よって、単にAR1モデルを適用するだけでは問題は解決できていない。 all.out %&gt;% ggplot(aes(x = Timelag, y = 0))+ geom_segment(aes(xend = Timelag, yend = Acf))+ geom_ribbon(aes(ymax = SE, ymin = -SE), alpha = 0.3)+ theme_bw()+ theme(aspect.ratio = 0.8)+ facet_rep_wrap(~ID, repeat.tick.labels = TRUE)+ labs(y = &quot;Auto-correlation&quot;) また、他の問題としてGAMMに時間のsmootherとAR1過程の両方が含まれている場合、これらが競合してしまう場合があることもある。この場合、どちらかのみを適用した方がよい。 References "],["Chapter4.html", "3 Spatial data and GLS 3.1 Variogram models for spatial dependency 3.2 Application on the Irish pH data 3.3 Matern correlation function", " 3 Spatial data and GLS 本章では、今度は空間的相関を持つデータにGLSを適用する。 3.1 Variogram models for spatial dependency 時系列データに対しては、異なる残差間の相関を以下のような関数\\(h()\\)で定義した。 \\[ h(\\phi, \\epsilon_t, \\epsilon_ss) = \\phi^{|t-s|} \\] しかし、空間データに対して全く同じことをすることはできない。その代わり、残差のバリオグラムの形に応じて数学的モデルを選択し、それを用いて残差の分散共分散行列\\(\\bf{\\Sigma}\\)を計算することになる。nlmeパッケージには、corExp、corSpher、corLin、corGaus、corRatioなど、残差の空間的なパターンをモデリングするための様々なモデルがある(これらは、カーネルとも呼ばれる)。それぞれのモデルは2つのパラメータを持つ。詳細な数学的表現については、?corClassesでヘルプを参照するか、 Dale and Fortin (2014) や 村上 (2022) を参照。 例えば、指数バリオグラム(corExp)は以下のように定義される。なお、\\(s\\)は2地点間の距離、\\(\\phi\\)はレンジ(range)と呼ばれるパラメータであり、自己相関がなくなるまでの距離を表す。 \\[ h(s, \\phi) = 1 - e^{-\\frac{s}{\\phi}} \\] 同様に、球形(corSpher)は以下のように定義される。 \\[ \\begin{aligned} h(s, \\phi) = \\begin{cases} 1 - \\frac{3}{2}\\frac{s}{\\phi} + \\frac{3}{2}(\\frac{s}{\\phi})^3 \\;\\; &amp;if \\; 0 \\le s &lt; \\phi \\\\ 0 \\;\\; &amp;if \\; \\phi &lt; s \\end{cases} \\end{aligned} \\] また、ガウス型(corGaus)は以下のように定義される。 \\[ h(s, \\phi) = exp \\Bigl( -\\bigl( \\frac{s}{\\phi} \\bigl)^2 \\Bigl) \\] これらのモデルは距離が0のときバリオグラムの値も0になってしまうため、距離が0のときのバリオグラムの値を指定することができる(= ナゲット効果)。 様々なモデルのバリオグラムを図示したのが以下である。 #corExp mydata &lt;- data.frame(D = seq(0,1,by = 0.1)) cprExp &lt;- NULL phi_exp = c(0.2, 0.3, 0.5) nugget = 0.2 for(i in seq_along(phi_exp)){ corExp(c(phi_exp[i],nugget), form = ~ mydata$D, ## ナゲット効果 nugget = T,) %&gt;% Initialize(,data=mydata) %&gt;% Variogram() %&gt;% mutate(phi = phi_exp[i], type = &quot;Exponential&quot;) -&gt; vario.out cprExp &lt;- bind_rows(cprExp, vario.out) } #CorSpher cprSph &lt;- NULL phi_sph = c(0.3, 0.5, 0.8) nagget = 0.3 for(i in seq_along(phi_sph)){ corSpher(c(phi_sph[i], nugget) , form = ~ mydata$D, nugget = T) %&gt;% Initialize(, data=mydata) %&gt;% Variogram() %&gt;% mutate(phi = phi_sph[i], type = &quot;Spherical&quot;) -&gt; vario.out cprSph &lt;- bind_rows(cprSph, vario.out) } #CorGaus cprGaus &lt;- NULL phi_gaus = c(0.3, 0.5, 0.8) nagget = 0.3 for(i in seq_along(phi_gaus)){ corGaus(c(phi_gaus[i], nugget) , form = ~ mydata$D, nugget = T) %&gt;% Initialize(, data=mydata) %&gt;% Variogram() %&gt;% mutate(phi = phi_gaus[i], type = &quot;Gaussian&quot;) -&gt; vario.out cprGaus &lt;- bind_rows(cprGaus, vario.out) } #CorRatio cprRatio &lt;- NULL phi_ratio = c(0.3, 0.5, 0.8) nagget = 0.3 for(i in seq_along(phi_ratio)){ corGaus(c(phi_ratio[i], nugget) , form = ~ mydata$D, nugget = T) %&gt;% Initialize(, data=mydata) %&gt;% Variogram() %&gt;% mutate(phi = phi_ratio[i], type = &quot;Ratio&quot;) -&gt; vario.out cprRatio &lt;- bind_rows(cprRatio, vario.out) } #CorLin cprLin &lt;- NULL phi_lin = c(0.3, 0.5, 0.8) nagget = 0.3 for(i in seq_along(phi_lin)){ corGaus(c(phi_lin[i], nugget) , form = ~ mydata$D, nugget = T) %&gt;% Initialize(, data=mydata) %&gt;% Variogram() %&gt;% mutate(phi = phi_lin[i], type = &quot;Lin&quot;) -&gt; vario.out cprLin &lt;- bind_rows(cprLin, vario.out) } ## 図示 bind_rows(cprExp, cprGaus, cprSph, cprRatio, cprLin) %&gt;% mutate(phi = as.factor(phi)) %&gt;% ggplot(aes(x = dist, y = variog))+ geom_line(aes(group = phi))+ facet_rep_wrap(~type, repeat.tick.labels = TRUE)+ theme_bw()+ theme(aspect.ratio = 1) 分析は以下の5ステップで行う。 空間的相関を考慮せずにモデリングを行う。 1のモデルの残差のバリオグラムを書く。 バリオグラムの形を基に、どのバリオグラムモデルを適用するか決める。 バリオグラムモデルを含み、空間的相関を考慮したモデリングを行う。 4のモデルが問題ないかをチェックする。 3.2 Application on the Irish pH data 本節では、第1.2節で分析したアイルランドの河川のpHを調べたデータを再び用いる。空間的相関を考慮しない通常の線形回帰については第1.2節ですでに実行しているため、これに関する説明は省略する(step1とstep2)。図??からどのバリオグラムモデルが適切かを判断することが難しいため、可能なバリオグラムモデルを全て当てはめる。 iph %&gt;% mutate(Xkm = Easting/1000, Ykm = Northing/1000) -&gt; iph m4_1 &lt;- gls(pH ~ SDI + logAltitude*fForested, data = iph, method = &quot;REML&quot;) ## 指数モデル m4_1_exp &lt;- update(m4_1, correlation =corExp(form = ~ Xkm + Ykm, nugget = TRUE)) ## Linモデル m4_1_lin &lt;- update(m4_1, correlation =corLin(form = ~ Xkm + Ykm, nugget = TRUE)) ## Gausモデル m4_1_gau &lt;- update(m4_1, correlation =corGaus(form = ~ Xkm + Ykm, nugget = TRUE)) ## 球形モデル m4_1_sph &lt;- update(m4_1, correlation =corSpher(form = ~ Xkm + Ykm, nugget = TRUE)) ## Ratioモデル m4_1_rat &lt;- update(m4_1, correlation =corRatio(form = ~ Xkm + Ykm, nugget = TRUE)) 各モデルのAICを比較すると指数モデル(m4_1_exp)と比率モデル(m4_1_rat)が最もAICが低い。しかし、その他の空間的相関を考慮したモデルはむしろAICが高くなっていることが分かる。このことは、これらのモデルで推定されたレンジ(\\(\\phi\\))の値が0に近いことを示している。 AIC(m4_1, m4_1_exp, m4_1_gau, m4_1_lin, m4_1_rat, m4_1_sph) 実際、時数モデルと比率モデル以外はレンジの推定値がほとんど0になっていることが分かる。 bind_rows(coef(m4_1_exp$modelStruct$corStruct, unconstrained = FALSE), coef(m4_1_lin$modelStruct$corStruct, unconstrained = FALSE), coef(m4_1_gau$modelStruct$corStruct, unconstrained = FALSE), coef(m4_1_sph$modelStruct$corStruct, unconstrained = FALSE), coef(m4_1_rat$modelStruct$corStruct, unconstrained = FALSE)) %&gt;% mutate(model = c(&quot;Exp&quot;,&quot;Lin&quot;,&quot;Gaussian&quot;,&quot;Spherical&quot;,&quot;Ratio&quot;)) %&gt;% select(model, everything()) これは、gls関数ではレンジphiを推定する際に、指定しなければ最短の距離の90%の値をアルゴリズムの初期値として使用するために生じている。この問題を回避するためには、以下のようにvalue =で初期値を指定する必要がある。ここでは、レンジに50、ナゲットに0.1を割り当てている(Linモデルだけ収束しなかったので、レンジの初期値に25を割り当てている)。 ## 指数モデル m4_1_exp2 &lt;- update(m4_1, correlation =corExp(form = ~ Xkm + Ykm, nugget = TRUE, value = c(50, 0.1))) ## Linモデル m4_1_lin2 &lt;- update(m4_1, correlation =corLin(form = ~ Xkm + Ykm, nugget = TRUE, value = c(25, 0.1))) ## Gausモデル m4_1_gau2 &lt;- update(m4_1, correlation =corGaus(form = ~ Xkm + Ykm, nugget = TRUE, value = c(50, 0.1))) ## 球形モデル m4_1_sph2 &lt;- update(m4_1, correlation =corSpher(form = ~ Xkm + Ykm, nugget = TRUE, value = c(50, 0.1))) ## Ratioモデル m4_1_rat2 &lt;- update(m4_1, correlation =corRatio(form = ~ Xkm + Ykm, nugget = TRUE, value = c(50, 0.1))) 新しいモデルでは、レンジの推定値が0に近くなくなっている。 bind_rows(coef(m4_1_exp2$modelStruct$corStruct, unconstrained = FALSE), coef(m4_1_lin2$modelStruct$corStruct, unconstrained = FALSE), coef(m4_1_gau2$modelStruct$corStruct, unconstrained = FALSE), coef(m4_1_sph2$modelStruct$corStruct, unconstrained = FALSE), coef(m4_1_rat2$modelStruct$corStruct, unconstrained = FALSE)) %&gt;% mutate(model = c(&quot;Exp&quot;,&quot;Lin&quot;,&quot;Gaussian&quot;,&quot;Spherical&quot;,&quot;Ratio&quot;)) %&gt;% select(model, everything()) これらのモデルのAICを比較すると、相関構造としてcorLinを持つモデルが最もAICが低いことが分かった。 AIC(m4_1, m4_1_exp2, m4_1_gau2, m4_1_lin2, m4_1_rat2, m4_1_sph2) このモデルの結果は以下の通り。 summary(m4_1_lin2) ## Generalized least squares fit by REML ## Model: pH ~ SDI + logAltitude * fForested ## Data: iph ## AIC BIC logLik ## 169.5945 196.1786 -76.79724 ## ## Correlation Structure: Linear spatial correlation ## Formula: ~Xkm + Ykm ## Parameter estimate(s): ## range nugget ## 67.2152946 0.5228704 ## ## Coefficients: ## Value Std.Error t-value p-value ## (Intercept) 8.175531 0.2766976 29.546811 0.0000 ## SDI -0.023739 0.0019874 -11.944746 0.0000 ## logAltitude 0.154131 0.1397899 1.102593 0.2715 ## fForestedyes 1.036179 0.3841835 2.697093 0.0076 ## logAltitude:fForestedyes -0.539765 0.1816375 -2.971661 0.0033 ## ## Correlation: ## (Intr) SDI lgAltt fFrstd ## SDI -0.061 ## logAltitude -0.931 -0.213 ## fForestedyes -0.380 -0.020 0.380 ## logAltitude:fForestedyes 0.411 -0.016 -0.406 -0.989 ## ## Standardized residuals: ## Min Q1 Med Q3 Max ## -5.1573493 -0.5666860 -0.1527922 0.4324576 2.7694846 ## ## Residual standard error: 0.392704 ## Degrees of freedom: 210 total; 205 residual 空間相関を考慮しないモデル(m4_1)と比較すると、推定値が少し変化しているようだ。95%信頼区間は一般的に空間的相関を考慮すれば大きくなるが、今回はあまり変わっていないように見える。 compare_parameters(m4_1, m4_1_lin2) バリオグラムを描画すると、まだ空間的相関が少しありそう? vario_4_1 &lt;- data.frame(resid = resid(m4_1_lin2, type = &quot;n&quot;), Xkm = iph$Xkm, Ykm = iph$Ykm) sp::coordinates(vario_4_1) &lt;- c(&quot;Xkm&quot;, &quot;Ykm&quot;) vario_4_1 %&gt;% variogram(resid ~ Xkm + Ykm, data = ., ## 0が南北方向、90が東西方向 alpha = c(0, 90), cressie = TRUE, cutoff = 150, width = 10) %&gt;% ggplot(aes(x = dist, y = gamma))+ geom_point(aes(size = np))+ theme_bw()+ theme(aspect.ratio = 1)+ facet_rep_wrap(~ dir.hor, labeller = as_labeller(c(&quot;0&quot; = &quot;North-South&quot;, &quot;90&quot; = &quot;East-West&quot;)))+ labs(y = &quot;semivariogram&quot;) 3.3 Matern correlation function Matern相関関数は以下のように書ける。なお、\\(s_i\\)と\\(s_j\\)はデータ\\(i\\)と\\(j\\)の空間的な場所を、\\(K_V\\)は第2種ベッセル関数を、\\(||s_i - s_j||\\)はデータ\\(i\\)と\\(j\\)のユークリッド距離を表す(ベッセル関数については高度な数学が必要のため、理解しなくていい)。\\(\\kappa\\)はAR1過程モデルの\\(\\phi\\)やバリオグラムモデルのレンジに相当するものである。\\(\\Gamma()\\)はガンマ関数である。 \\[ cor_{Matern}(s_i, s_j) = \\frac{2^{1-V}}{\\Gamma(V)} \\times (\\kappa \\times ||s_i - s_j||)^V \\times K_V(\\kappa \\times ||s_i - s_j||) \\] Matern相関関数を図示したのが図??である。AR1過程やバリオグラムモデルのように、空間的に近いデータ同士の相関は高く、空間的に離れるほど相関が低くなっていくことが分かる。Matern関数はglsには実装されていないが、のちに学ぶINLAパッケージには実装されている。 library(fields) crossing(kappa = c(0.02,0.07,0.2), distance = seq(0,100,length =100)) %&gt;% mutate(correlation = ifelse(distance != 0, (kappa * distance) * besselK(kappa * distance, 1), 1)) %&gt;% mutate(kappa = as.factor(kappa)) %&gt;% ggplot(aes(x = distance, y = correlation))+ geom_line(aes(linetype = kappa))+ theme_bw()+ theme(aspect.ratio = 1) References "],["Chapter5.html", "4 Linear mixed-effects models and dependency 4.1 White Storks 4.2 Considering the data (wrongly) as one-way nested 4.3 Fitting the one-way nested model using lmer 4.4 Model validation 4.5 Sketching the fitted value 4.6 Considering the data (correctly) as two-way nested", " 4 Linear mixed-effects models and dependency 本節では、混合モデルがどのようにデータの非独立性に対処しているのかを見ていく。 4.1 White Storks ここでは、シュバシコウの成長に影響を与える要因を調べた Bouriach et al. (2015) の研究データを用いる。あるコロニー内の多くの巣から、各巣内の複数の雛のデータが複数回ずつにわたって最大生後54日まで収集されている。 ws &lt;- read_csv(&quot;data/whitestork.csv&quot;) datatable(ws, options = list(scrollX = 20), filter = &quot;top&quot;) 雛の成長度合いは、くちばし長で評価されている。図??は年齢とくちばし長の関連を図示したものである。 ws %&gt;% ggplot(aes(x = age, y = beak))+ geom_point(shape =1, size = 1.5)+ theme_bw()+ theme(aspect.ratio = 1)+ labs(y = &quot;Beak length&quot;, x = &quot;Age&quot;) 図4.1: Scatterplot of beak length (mm) of White Stork chicks versus age (in days). 4.2 Considering the data (wrongly) as one-way nested まず、以下のモデルを考える(回帰係数は省略している)。BLはくちばし長、Ageは日齢、Chickは雛のID、Nestはそのデータが得られた巣のIDを表す。 \\[ \\begin{aligned} BL_i &amp;= Intercept + Age_i + Nest_i + Chick_i + \\epsilon_i \\\\ \\epsilon_i &amp;\\sim N(0, \\sigma^2) \\end{aligned} \\] このモデルには2つの大きな問題がある。 巣IDと雛IDは多いので、モデルで膨大なパラメータを推定することになる。 同じ雛/巣から複数のデータが収集されており、疑似反復が生じている。 この問題を解決する方法として、巣ごとの平均をとることができるがサンプルサイズが著しく減少する。また、巣ごとの平均くちばし長というのは生物学的に見て意味のあるものだとは思えない。混合mドエルはこれらの問題を解決する。 4.2.1 model formulation まずは、以下の混合モデルを考える。このモデルは、雛IDについてはひとまず無視し、巣IDをランダム切片として含めている。なお、\\(i\\)は巣IDを表し、\\(j = 1,2,3,\\dots,n_i\\)は巣ごとのデータ数を表す。ここでは、\\(a_i\\)と\\(\\epsilon_{ij}\\)は独立であると仮定されている。 \\[ \\begin{aligned} BL_{ij} &amp;= Intercept + Age_{ij} + a_i + \\epsilon_{ij} \\\\ a_i &amp;\\sim N(0, \\sigma_{nest}^2)\\\\ \\epsilon_{ij} &amp;\\sim N(0, \\sigma^2) \\end{aligned} \\] このモデルは、以下のようにも書ける。 \\[ \\begin{aligned} BL_{ij} &amp;= N(\\mu_{ij}, \\sigma^2)\\\\ E(BL_{ij}) &amp;= \\mu_{ij} \\;\\; and \\;\\; var(BL_{ij}) = \\sigma^2 \\\\ \\mu_{ij} &amp;= Intercept + Age_{ij} + a_i \\\\ a_i &amp;\\sim N(0, \\sigma_{nest}^2)\\\\ \\end{aligned} \\tag{4.1} \\] 生態学では、一元配置入れ子モデル(one-way nested model)の線形混合効果モデルと呼ばれる。それでは、混合モデルはどのようにデータの非独立性に対応しているのだろうか。 同じ巣の雛同士は、同じ親に育てられ、生息環境が同じであり、遺伝的にも類似している。よって、同じ巣の雛のくちばし長は独立ではなく、他の巣の雛のくちばし長よりも類似していると考えられる。 同じ巣の雛のくちばし長同士の相関は、この混合モデルでは以下のように書ける。これは級内相関係数(inter class correlation: ICC)とも呼ばれる。なお、このモデルでは異なる巣の雛のくちばし長同士の相関は0であると仮定される。混合モデルでは、このように巣内のデータの非独立性が考慮される。 \\[ cor(BL_{ij}, BL_{ik}) = \\phi = \\frac{\\sigma_{nest}^2}{\\sigma_{nest}^2 + \\sigma^2} \\tag{4.2} \\] 巣1(データ数が6)のデータの相関行列は以下のように書ける。 \\[ \\bf{\\Sigma_1} = cor \\begin{pmatrix} BL_{1,1}\\\\ BL_{1,2}\\\\ BL_{1,3}\\\\ BL_{1,4}\\\\ BL_{1,5}\\\\ BL_{1,6}\\\\ \\end{pmatrix} = \\begin{pmatrix} 1 &amp; \\phi &amp; \\phi &amp; \\phi &amp; \\phi &amp; \\phi \\\\ \\phi &amp; 1 &amp; \\phi &amp; \\phi &amp; \\phi &amp; \\phi \\\\ \\phi &amp; \\phi &amp; 1 &amp; \\phi &amp; \\phi &amp; \\phi \\\\ \\phi &amp; \\phi &amp; \\phi &amp; 1 &amp; \\phi &amp; \\phi \\\\ \\phi &amp; \\phi &amp; \\phi &amp; \\phi &amp; 1 &amp; \\phi \\\\ \\phi &amp; \\phi &amp; \\phi &amp; \\phi &amp; \\phi &amp; 1 \\\\ \\end{pmatrix} \\] 他の巣についても同じように書ける(データ数に応じて行列数が変わるだけである)。よって、全ての巣のデータの相関係数は以下のように書ける。なお、\\(n_1, n_2, \\dots, n_73\\)は各巣のデータ数である。以上で見たように、同じ巣のデータ同士の相関は\\(\\phi\\)、異なる巣のデータ同士の相関は0であると仮定される。 \\[ \\begin{aligned} cor \\begin{pmatrix} \\begin{pmatrix} BL_{1,1}\\\\ \\vdots\\\\ BL_{1,n_1} \\end{pmatrix}\\\\ \\begin{pmatrix} BL_{2,1}\\\\ \\vdots\\\\ BL_{2,n_2} \\end{pmatrix}\\\\ \\vdots \\\\ \\begin{pmatrix} BL_{73,1}\\\\ \\vdots\\\\ BL_{73,n_{73}} \\end{pmatrix} \\end{pmatrix} = \\begin{pmatrix} \\bf{\\Sigma_1} &amp; 0 &amp; \\cdots &amp; 0\\\\ 0 &amp; \\bf{\\Sigma_2} &amp; \\cdots &amp; 0\\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ 0 &amp; 0 &amp; \\cdots &amp; \\bf{\\Sigma_{73}} \\\\ \\end{pmatrix} \\end{aligned} \\] なお、式(4.2)は一つのランダム切片を持つ線形混合モデルについてのみ当てはまる。一般化線形混合モデル(GLMM)や2つ以上のランダム切片/ランダム傾きをもつ線形混合モデルについては異なる表現が用いられる。 混合モデルはGLSと同様にデータ間の相関をモデルに組み込むことによって、データの非独立性に対処している。なお、ランダム切片の分散\\(\\sigma_{nest}^2\\)について正確な推定を行うためには、少なくとも5以上のクラスター(今回の場合は巣ID)がなくてはならない。 4.3 Fitting the one-way nested model using lmer それでは、モデル??をRで実行する。ここでは、lme4パッケージのlmer関数を用いる。分析には2012年のデータのみを用いる。 ws2 &lt;- drop_na(ws, beak, age, nest, chick) %&gt;% mutate(fnest = as.factor(nest), fchick = as.factor(chick)) %&gt;% filter(year == &quot;2012&quot;) %&gt;% data.frame() m5_1 &lt;- lmer(beak ~ age + (1|fnest), data = ws2) 結果は以下の通り。 summary(m5_1) ## Linear mixed model fit by REML [&#39;lmerMod&#39;] ## Formula: beak ~ age + (1 | fnest) ## Data: ws2 ## ## REML criterion at convergence: 10234.3 ## ## Scaled residuals: ## Min 1Q Median 3Q Max ## -4.9103 -0.5406 -0.0259 0.5768 6.3796 ## ## Random effects: ## Groups Name Variance Std.Dev. ## fnest (Intercept) 57.23 7.565 ## Residual 62.50 7.905 ## Number of obs: 1438, groups: fnest, 73 ## ## Fixed effects: ## Estimate Std. Error t value ## (Intercept) 44.4417 0.9651 46.05 ## age 2.9925 0.0169 177.08 ## ## Correlation of Fixed Effects: ## (Intr) ## age -0.301 モデルの結果から、モデル式は以下のように推定されたことが分かる。2行目から\\(a_i\\)を除いた\\(\\mu_{ij} = 44.44 + 2.99\\times Age_{ij}\\)の部分はモデルのfixed partと呼ばれ、平均的な巣におけるくちばし長の期待値を表す(ランダム切片を含まないので)。 \\[ \\begin{aligned} BL_{ij} &amp;= N(\\mu_{ij}, 7.90^2)\\\\ \\mu_{ij} &amp;= 44.44 + 2.99\\times Age_{ij} + a_i \\\\ a_i &amp;\\sim N(0, 7.56^2)\\\\ \\end{aligned} \\] 級内相関\\(\\phi\\)は以下のように求められる。 \\[ \\phi = \\frac{7.56^2}{7.56^2 + 7.90^2} = 0.49 \\] Rでは以下のように求める。よって、同じ巣内のデータ同士の相関は0.47と推定されたことが分かる。 sigma_ranef &lt;- VarCorr(m5_1) %&gt;% as.data.frame() %&gt;% .[1,5] sigma_ranef^2/(sigma_ranef^2 + sigma(m5_1)^2) ## [1] 0.4780135 fixed partの予測値と95%信頼区間を表したのが図4.2である。 nd5_1 &lt;- data.frame(age = seq(min(ws2$age), max(ws2$age), by = 1)) ## 説明変数を含む行列 X &lt;- model.matrix(~age, data = nd5_1) ## 予測値と95％信頼区間の算出 fitted5_1 &lt;- nd5_1 %&gt;% ## 予測値はbeta × Xで求まる mutate(fitted = X %*% fixef(m5_1) %&gt;% .[,1]) %&gt;% ## 予測値のseは以下の通り mutate(se = sqrt(diag(X %*% vcov(m5_1) %*% t(X)))) %&gt;% mutate(ci.low = fitted - 1.96*se, ci.high = fitted + 1.96*se) fitted5_1 %&gt;% ggplot(aes(x = age, y = fitted))+ geom_line()+ geom_ribbon(aes(ymin = ci.low, ymax = ci.high), alpha = 0.2)+ geom_point(data = ws2, aes(y = beak), shape =1, size = 1.5)+ theme_bw()+ theme(aspect.ratio = 1)+ labs(y = &quot;Beak length&quot;, x = &quot;Age&quot;) 図4.2: Fixed part of the linear mixed-effects model. The shaded area is a 95% confidence interval for the mean. 4.4 Model validation このモデルはまだ性別の効果を考慮していない他、雛IDの非独立性についても考慮していない。よって、ここではモデル診断は行わない。 4.5 Sketching the fitted value それぞれの巣について推定された\\(a_i\\)は以下の通り。これは、モデルのrandom partと呼ばれる。 ranef(m5_1) %&gt;% data.frame() %&gt;% rename(estimated = condval, sd = condsd) %&gt;% mutate_if(is.numeric, ~round(., 2)) %&gt;% datatable() fixed partとrandom partを足した各巣の予測値を示したのが図4.3である。なお、赤い線は図4.2で示したfixed partのみの直線を示している。それぞれの直線は、ここランダム効果の分だけ上/下にシフトしている。 predict(m5_1) %&gt;% data.frame() %&gt;% rename(predicted = 1) %&gt;% bind_cols(ws2) %&gt;% ggplot(aes(x = age))+ geom_line(aes(y = predicted, group = fnest))+ geom_point(aes(y = beak), shape = 1,size =1.5)+ geom_line(data= fitted5_1, aes(y = fitted), color = &quot;red3&quot;, linewidth = 1)+ theme_bw()+ theme(aspect.ratio = 1)+ labs(y = &quot;Beak length&quot;, x = &quot;Age&quot;) 図4.3: Fixed part plus the random effects for the linear mixed-effects model. 4.6 Considering the data (correctly) as two-way nested さて、それでは次に雛IDも考慮したモデルを考える。データでは同じ雛から複数のデータが収集されており、ここでも疑似反復が生じているからである。同じ雛から得られたデータは、同じ巣の他の雛のデータよりも類似していると考えられる。 以下のようなモデルを考える。このようなモデルは、two-way nested linear mixed-effects modelと呼ばれる。なお、\\(i\\)は巣IDを、\\(j\\)は巣ごとの雛IDを、\\(k\\)は巣\\(i\\)における\\(j\\)番目の雛の\\(k\\)個目のデータであることを表す。 \\[ \\begin{aligned} BL_{ijk} &amp;= N(\\mu_{ijk}, \\sigma^2)\\\\ E(BL_{ijk}) &amp;= \\mu_{ijk} \\;\\; and \\;\\; var(BL_{ijk}) = \\sigma^2 \\\\ \\mu_{ijk} &amp;= Intercept + Age_{ijk} + a_i + b_{ij} \\\\ a_i &amp;\\sim N(0, \\sigma_{nest}^2)\\\\ b_{ij} &amp;\\sim N(0, \\sigma_{chick}^2)\\\\ \\end{aligned} \\tag{4.3} \\] このモデルでは、同じ巣内の異なるデータ間に相関があり、かつ同じ雛の異なるデータ間にも相関があることを仮定している。なお、異なる巣のデータ間は独立だと仮定されている。 同じ巣内の同じ雛のデータ間の相関は以下の式で与えられる。 \\[ \\phi_{chick} = \\frac{\\sigma_{nest}^2 + \\sigma_{chick}^2}{\\sigma_{nest}^2 + \\sigma_{chick}^2 + \\sigma^2} \\] また、同じ巣内の異なる雛間のデータの相関は以下の式で表せられる。 \\[ \\phi_{nest} = \\frac{\\sigma_{nest}^2}{\\sigma_{nest}^2 + \\sigma_{chick}^2 + \\sigma^2} \\] このモデルは、Rで以下のように実行できる。 m5_2 &lt;- lmer(beak ~ age + (1|fnest/fchick), data = ws2) 結果は以下の通り。 summary(m5_2) ## Linear mixed model fit by REML [&#39;lmerMod&#39;] ## Formula: beak ~ age + (1 | fnest/fchick) ## Data: ws2 ## ## REML criterion at convergence: 9932.6 ## ## Scaled residuals: ## Min 1Q Median 3Q Max ## -4.3657 -0.5617 -0.0678 0.5513 6.9810 ## ## Random effects: ## Groups Name Variance Std.Dev. ## fchick:fnest (Intercept) 29.70 5.449 ## fnest (Intercept) 47.81 6.915 ## Residual 40.81 6.388 ## Number of obs: 1438, groups: fchick:fnest, 262; fnest, 73 ## ## Fixed effects: ## Estimate Std. Error t value ## (Intercept) 44.41110 0.93656 47.42 ## age 2.97532 0.01406 211.63 ## ## Correlation of Fixed Effects: ## (Intr) ## age -0.245 iccはそれぞれ\\(phi_{chick} = 0.66\\)、\\(phi_{nest} = 0.40\\)と推定された。 sigma_chick &lt;- VarCorr(m5_2) %&gt;% as.data.frame() %&gt;% .[1,5] sigma_nest &lt;- VarCorr(m5_2) %&gt;% as.data.frame() %&gt;% .[2,5] sigma &lt;- sigma(m5_2) ## phi_nest sigma_nest^2/(sigma^2 + sigma_chick^2 + sigma_nest^2) ## [1] 0.4040858 ## phi_chick (sigma_nest^2+sigma_chick^2)/(sigma^2 + sigma_chick^2 + sigma_nest^2) ## [1] 0.6550681 モデルの結果を図示したのが図4.4である。黒い線はモデルの fixed partの予測値を、赤い点線は巣6(Ap2)の予測値(\\(\\mu_{ijk} + a_i\\))を示している。また、2本の赤い直線は巣6の雛2頭の予測値(\\(\\mu_{ijk} + a_i + b_{ij}\\))を、赤い点はその2頭のデータを示している。これを見ると、2頭の雛の予測値は巣の予測値から近いことが分かる。これは、雛IDのランダム切片よりも巣IDのランダム切片の方が予測値への影響が大きいことを示している。\\(\\phi_{chick}\\)と\\(\\phi_{nest}\\)の値が近いほどこのことがいえる。 re_Ap2 &lt;- ranef(m5_2)$fnest[6,1] fitted5_2_fixed &lt;- ggpredict(m5_2, terms = &quot;age[1:54,by=0.1]&quot;, type = &quot;fixed&quot;) %&gt;% rename(age = x) %&gt;% mutate(fitted_Ap2 = predicted + re_Ap2) fitted5_2 &lt;- predict(m5_2) %&gt;% data.frame() %&gt;% bind_cols(ws2) %&gt;% rename(fitted = 1) fitted5_2_fixed %&gt;% ggplot(aes(x = age, y = predicted))+ geom_line(linewidth = 1)+ geom_line(aes(y = fitted_Ap2), data = . %&gt;% filter(age &gt;= 6 &amp; age &lt;= 29), linewidth = 0.8, color = &quot;red3&quot;, linetype = &quot;dashed&quot;)+ geom_line(data = fitted5_2 %&gt;% filter(fnest== &quot;Ap2&quot;), aes(y = fitted, group = fchick), color = &quot;red3&quot;, linewidth = 1)+ geom_point(data = ws2, aes(y = beak), shape = 1, size = 1) + geom_point(data = ws2 %&gt;% filter(fnest == &quot;Ap2&quot;), aes(y = beak, shape = fchick), size = 4, color = &quot;red3&quot;)+ scale_shape_manual(values = c(16,18))+ theme_bw()+ theme(aspect.ratio = 1) 図4.4: Fitted values due to the fixed part, fixed part + the random intercept Nest, and fixed part + the random intercept Nest + the random intercept Chick. compare_parameters(m5_1, m5_2, select = &quot;{estimate}&lt;br&gt;({se})|{p}&quot;) %&gt;% data.frame() %&gt;% mutate_if(is.numeric, ~round(.,2)) %&gt;% select(1,4,5,12,13) References "],["sessioninfo.html", "実行環境", " 実行環境 sessionInfo() ## R version 4.2.2 (2022-10-31 ucrt) ## Platform: x86_64-w64-mingw32/x64 (64-bit) ## Running under: Windows 10 x64 (build 22621) ## ## Matrix products: default ## ## locale: ## [1] LC_COLLATE=Japanese_Japan.utf8 LC_CTYPE=Japanese_Japan.utf8 ## [3] LC_MONETARY=Japanese_Japan.utf8 LC_NUMERIC=C ## [5] LC_TIME=Japanese_Japan.utf8 ## ## attached base packages: ## [1] parallel splines stats graphics grDevices utils datasets ## [8] methods base ## ## other attached packages: ## [1] fields_15.2 viridisLite_0.4.2 ## [3] spam_2.9-1 scales_1.2.1 ## [5] NipponMap_0.2 sf_1.0-14 ## [7] fontregisterer_0.3 systemfonts_1.0.4 ## [9] extrafont_0.18 gganimate_1.0.8 ## [11] lemon_0.4.6 ggsci_2.9 ## [13] concaveman_1.1.0 ggforce_0.4.1 ## [15] ggdag_0.2.7 dagitty_0.3-1 ## [17] kableExtra_1.3.4 knitr_1.43 ## [19] DT_0.27 patchwork_1.1.2 ## [21] ggrepel_0.9.2 GGally_2.1.2 ## [23] ggnewscale_0.4.9 htmlwidgets_1.6.2 ## [25] plotly_4.10.1 sp_1.5-1 ## [27] geoR_1.9-2 lubridate_1.9.0 ## [29] timechange_0.1.1 data.table_1.14.6 ## [31] see_0.7.5.5 report_0.5.7.4 ## [33] parameters_0.20.3 performance_0.10.3 ## [35] modelbased_0.8.6.3 insight_0.19.1.4 ## [37] effectsize_0.8.3.6 datawizard_0.7.1.1 ## [39] correlation_0.8.4 bayestestR_0.13.1 ## [41] easystats_0.6.0.8 forcats_1.0.0 ## [43] stringr_1.5.0 dplyr_1.1.2 ## [45] purrr_1.0.0 readr_2.1.3 ## [47] tidyr_1.2.1 tibble_3.2.1 ## [49] ggplot2_3.4.2 tidyverse_1.3.2 ## [51] ggeffects_1.1.4 DHARMa.helpers_0.0.0.9000 ## [53] DHARMa_0.4.6 cmdstanr_0.5.3 ## [55] rstan_2.26.13 StanHeaders_2.26.13 ## [57] brms_2.18.0 Rcpp_1.0.11 ## [59] gstat_2.1-1 gratia_0.8.1.34 ## [61] gamlss_5.4-12 gamlss.dist_6.0-5 ## [63] MASS_7.3-58.1 gamlss.data_6.0-2 ## [65] gamm4_0.2-6 lme4_1.1-34 ## [67] Matrix_1.5-1 mgcv_1.8-41 ## [69] nlme_3.1-160 ## ## loaded via a namespace (and not attached): ## [1] estimability_1.4.1 spacetime_1.3-0 coda_0.19-4 ## [4] intervals_0.15.4 dygraphs_1.1.1.6 inline_0.3.19 ## [7] generics_0.1.3 callr_3.7.3 mvnfast_0.2.8 ## [10] proxy_0.4-27 tzdb_0.3.0 webshot_0.5.4 ## [13] xml2_1.3.5 httpuv_1.6.7 assertthat_0.2.1 ## [16] gargle_1.2.1 xfun_0.39 hms_1.1.3 ## [19] jquerylib_0.1.4 bayesplot_1.10.0 evaluate_0.21 ## [22] promises_1.2.0.1 fansi_1.0.3 progress_1.2.2 ## [25] dbplyr_2.2.1 readxl_1.4.1 igraph_1.3.5 ## [28] DBI_1.1.3 reshape_0.8.9 tensorA_0.36.2 ## [31] googledrive_2.0.0 stats4_4.2.2 ellipsis_0.3.2 ## [34] crosstalk_1.2.0 backports_1.4.1 V8_4.2.2 ## [37] bookdown_0.34 markdown_1.7 RcppParallel_5.1.6 ## [40] vctrs_0.6.2 abind_1.4-5 cachem_1.0.6 ## [43] withr_2.5.0 checkmate_2.1.0 emmeans_1.8.3 ## [46] xts_0.12.2 prettyunits_1.1.1 svglite_2.1.1 ## [49] splancs_2.01-44 dotCall64_1.0-2 lazyeval_0.2.2 ## [52] crayon_1.5.2 labeling_0.4.2 units_0.8-1 ## [55] pkgconfig_2.0.3 tweenr_2.0.2 rlang_1.1.1 ## [58] lifecycle_1.0.3 miniUI_0.1.1.1 colourpicker_1.2.0 ## [61] extrafontdb_1.0 modelr_0.1.10 cellranger_1.1.0 ## [64] distributional_0.3.2 tcltk_4.2.2 polyclip_1.10-4 ## [67] matrixStats_0.63.0 loo_2.5.1 boot_1.3-28 ## [70] zoo_1.8-11 reprex_2.0.2 base64enc_0.1-3 ## [73] processx_3.8.0 googlesheets4_1.0.1 KernSmooth_2.23-20 ## [76] classInt_0.4-8 shinystan_2.6.0 magrittr_2.0.3 ## [79] plyr_1.8.8 threejs_0.3.3 compiler_4.2.2 ## [82] rstantools_2.2.0 RColorBrewer_1.1-3 cli_3.6.0 ## [85] ps_1.7.2 Brobdingnag_1.2-9 tidyselect_1.2.0 ## [88] stringi_1.7.8 highr_0.10 yaml_2.3.7 ## [91] bridgesampling_1.1-2 grid_4.2.2 sass_0.4.5 ## [94] tools_4.2.2 rstudioapi_0.15.0 gridExtra_2.3 ## [97] posterior_1.3.1 farver_2.1.1 digest_0.6.31 ## [100] FNN_1.1.3.2 shiny_1.7.4 broom_1.0.2 ## [103] later_1.3.0 httr_1.4.4 colorspace_2.0-3 ## [106] rvest_1.0.3 fs_1.5.2 shinythemes_1.2.0 ## [109] xtable_1.8-4 jsonlite_1.8.4 nloptr_2.0.3 ## [112] tidygraph_1.2.2 R6_2.5.1 pillar_1.9.0 ## [115] htmltools_0.5.4 mime_0.12 glue_1.6.2 ## [118] fastmap_1.1.0 minqa_1.2.5 class_7.3-20 ## [121] codetools_0.2-18 maps_3.4.1 ggokabeito_0.1.0 ## [124] pkgbuild_1.4.0 mvtnorm_1.1-3 utf8_1.2.2 ## [127] lattice_0.20-45 bslib_0.4.2 curl_4.3.3 ## [130] gtools_3.9.4 magick_2.7.4 shinyjs_2.1.0 ## [133] Rttf2pt1_1.3.8 survival_3.5-5 rmarkdown_2.23 ## [136] munsell_0.5.0 e1071_1.7-12 haven_2.5.1 ## [139] reshape2_1.4.4 gtable_0.3.3 References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
