[["index.html", "Introduction to spatial-temporal data anlysis using R 本稿の目的", " Introduction to spatial-temporal data anlysis using R Tsubasa Yamaguchi 2023-09-06 本稿の目的 本稿は、一般化加法モデル(GAM)の概要を解説し、それをRで実行する方法を学ぶことを目的とする。本稿の内容はこちらから読むことができる。 GAMは一般化線形モデル(GLMに代表される線形なモデルを拡張し、変数間の関係をより柔軟な形で表現できるようにしたものである。そのため、GLMで仮定されるような単調増加または単調減少の関係だけでなく、非線形な関係を調べることができる。 霊長類の行動のような複雑なデータでは変数間の関係が非線形になることがしばしばあるため、GAMは多くの研究で用いられている(e.g., Matsumoto2017?; Taniguchi2018?; Hongo2022?)。GLMのように線形性を仮定するモデルがデータに当てはまらない場合には、GAMなどの非線形性を許容するモデルを使用する必要性が生じてくるだろう。 本稿は、Alain Zuurが執筆した”A beginner’s guide to generalized additive models with R”(Zuur2012?)の内容を基に執筆している。本書はなるべく数学的な説明を省きつつ、実際の生態学のデータを用いてGAMについてわかりやすく解説したもので、GAMの入門として非常によい書籍である。より詳細な情報を知りたい場合は原著にアクセスしていただきたい。 その他に参考にしたのは以下の本である。 (Zuur2009?) Mixed effects models and extensions in ecology with R. (James2013?) An Introduction to Statistical Learning with Applications in R. (Takezawa2009?) Rによるノンパラメトリック回帰の入門講義 "],["Chapter0.html", "0. パッケージの読み込み", " 0. パッケージの読み込み 本稿はRの基本操作とtidyverseパッケージによるデータハンドリングができることを前提としている。tidyverseパッケージを用いたデータ処理については、以下の書籍などを参照。 R for Data Science (Wickham2016?) 電子書籍, 日本語 R Graphics Coocbook 2nd Edition (Chang2018?) 電子書籍, 日本語 RユーザのためのRstudio[実践]入門~tidyverseによるモダンな分析フローの世界 改訂2版 (Matsumura2021?) 出版社サイト 使用するパッケージは以下のとおりである。GAMの実行は主にgamパッケージ(Hastie2018?)を用い、結果の作図についてはggplotパッケージでGAMの結果を可視化することに特化したgratiaパッケージを用いる。 ## GAM library(mgcv) library(gamm4) library(nlme) library(gamlss) library(gratia) library(gstat) library(MASS) library(brms) library(rstan) library(cmdstanr) library(DHARMa) library(DHARMa.helpers) library(ggeffects) ## データハンドリング library(tidyverse) library(easystats) library(data.table) library(lubridate) ## グラフや表関連 library(geoR) library(sp) library(plotly) library(htmlwidgets) library(ggnewscale) library(GGally) library(ggrepel) library(patchwork) library(DT) library(knitr) library(kableExtra) library(dagitty) library(ggdag) library(ggforce) library(concaveman) library(ggsci) library(lemon) library(gganimate) ## フォント関連 library(extrafont) require(systemfonts) require(fontregisterer) "],["Chapter2.html", "1 Recognizing statistical dependency 1.1 Linear regression applied to spatial data 1.2 GAM applied to temporal data", " 1 Recognizing statistical dependency 1.1 Linear regression applied to spatial data 本節では、Cruikshanks et al. (2006) のデータを用いる。この研究では、アイルランドの257の川において、川のpHがSDI(Sodium Dominance Index; 陽イオン中のナトリウムイオン)と関連しているかを、緯度(Altitude)やその場所が森林化されているか(Forested)も考慮したうえで調べている。 1.1.1 Visualization データは以下の通り。 iph &lt;- read_delim(&quot;data/Irishph.txt&quot;) %&gt;% mutate(fForested = ifelse(Forested == &quot;1&quot;, &quot;yes&quot;, &quot;no&quot;)) %&gt;% data.frame() datatable(iph, options = list(scrollX = 20), filter = &quot;top&quot;) 各説明変数との関連は以下の通り。 iph %&gt;% select(Altitude, pH, fForested, SDI) %&gt;% pivot_longer(cols = c(Altitude, SDI)) %&gt;% ggplot(aes(x = value, y = pH))+ geom_point(aes(color = fForested))+ geom_smooth(aes(color = fForested), method = &quot;lm&quot;)+ facet_rep_wrap(~ name, scales = &quot;free_x&quot;, repeat.tick.labels = TRUE)+ theme_bw()+ theme(aspect.ratio = 1)+ labs(x = &quot;Covariates&quot;) 1.1.2 Dependency 以下の線形モデルを適用するとする。 \\[ \\begin{aligned} pH_i &amp;\\sim N(0,\\sigma^2)\\\\ \\mu_i &amp;= \\beta_1 + \\beta_2 \\times SDI_i\\\\ \\end{aligned} \\] 結果を図示すると以下のようになる。 m2_1 &lt;- lm(pH ~ SDI, data = iph) ggpredict(m2_1, terms = &quot;SDI[7:72,by=0.1]&quot;, interval = &quot;prediction&quot;) %&gt;% data.frame() %&gt;% mutate(type = &quot;prediction&quot;) %&gt;% bind_rows(ggpredict(m2_1, terms = &quot;SDI[7:72,by=0.1]&quot;, interval = &quot;confidence&quot;) %&gt;% data.frame() %&gt;% mutate(type = &quot;confidence&quot;)) %&gt;% rename(SDI = x) %&gt;% ggplot(aes(x = SDI, y = predicted))+ geom_ribbon(aes(ymin = conf.high, ymax = conf.low, fill = type), alpha = 0.5)+ scale_fill_grey()+ geom_line()+ geom_point(data = iph, aes(y = pH), shape = 1)+ theme_bw()+ theme(aspect.ratio = 1) 1.1.3 Fit the model 全部の交互作用を含むモデルを考える。 iph %&gt;% mutate(logAltitude = log(Altitude)) -&gt; iph m2_2 &lt;- lm(pH ~ SDI*fForested*logAltitude, data = iph) 結果は以下の通り。 summary(m2_2) ## ## Call: ## lm(formula = pH ~ SDI * fForested * logAltitude, data = iph) ## ## Residuals: ## Min 1Q Median 3Q Max ## -1.94554 -0.18644 -0.01226 0.21667 1.13820 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 8.250624 0.765918 10.772 &lt;2e-16 *** ## SDI -0.028011 0.017190 -1.630 0.105 ## fForestedyes 1.794536 2.070682 0.867 0.387 ## logAltitude 0.046122 0.169691 0.272 0.786 ## SDI:fForestedyes -0.008168 0.037112 -0.220 0.826 ## SDI:logAltitude 0.000766 0.003741 0.205 0.838 ## fForestedyes:logAltitude -0.384565 0.439572 -0.875 0.383 ## SDI:fForestedyes:logAltitude 0.001552 0.007791 0.199 0.842 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.3756 on 202 degrees of freedom ## Multiple R-squared: 0.5675, Adjusted R-squared: 0.5525 ## F-statistic: 37.86 on 7 and 202 DF, p-value: &lt; 2.2e-16 あまりに煩雑なのでAICによるモデル選択を行う。 stepAIC(m2_2) ## Start: AIC=-403.47 ## pH ~ SDI * fForested * logAltitude ## ## Df Sum of Sq RSS AIC ## - SDI:fForested:logAltitude 1 0.0055954 28.498 -405.43 ## &lt;none&gt; 28.492 -403.47 ## ## Step: AIC=-405.43 ## pH ~ SDI + fForested + logAltitude + SDI:fForested + SDI:logAltitude + ## fForested:logAltitude ## ## Df Sum of Sq RSS AIC ## - SDI:fForested 1 0.00454 28.503 -407.39 ## - SDI:logAltitude 1 0.01654 28.515 -407.31 ## &lt;none&gt; 28.498 -405.43 ## - fForested:logAltitude 1 1.01027 29.508 -400.11 ## ## Step: AIC=-407.39 ## pH ~ SDI + fForested + logAltitude + SDI:logAltitude + fForested:logAltitude ## ## Df Sum of Sq RSS AIC ## - SDI:logAltitude 1 0.01443 28.517 -409.29 ## &lt;none&gt; 28.503 -407.39 ## - fForested:logAltitude 1 1.08368 29.586 -401.56 ## ## Step: AIC=-409.29 ## pH ~ SDI + fForested + logAltitude + fForested:logAltitude ## ## Df Sum of Sq RSS AIC ## &lt;none&gt; 28.517 -409.29 ## - fForested:logAltitude 1 1.2837 29.801 -402.04 ## - SDI 1 29.3674 57.884 -262.62 ## ## Call: ## lm(formula = pH ~ SDI + fForested + logAltitude + fForested:logAltitude, ## data = iph) ## ## Coefficients: ## (Intercept) SDI fForestedyes ## 8.10382 -0.02461 1.29402 ## logAltitude fForestedyes:logAltitude ## 0.07944 -0.28647 AICが最小のモデルは以下の通り。 m2_3 &lt;- lm(pH ~ SDI + logAltitude*fForested, data = iph) 1.1.4 Model validation 1.1.4.1 Check homogeinity and model misfit 標準化残差と予測値、各共変量の関係は問題ないよう。 resid &lt;- rstandard(m2_3) data.frame(resid = resid, fitted = predict(m2_3)) %&gt;% ggplot(aes(x = fitted, y = resid))+ geom_point(shape = 1)+ theme_bw()+ theme(aspect.ratio = 1)+ geom_hline(yintercept = 0, linetype = &quot;dashed&quot;) iph %&gt;% mutate(resid = resid) %&gt;% select(resid, SDI, logAltitude) %&gt;% pivot_longer(cols = c(SDI, logAltitude)) %&gt;% ggplot(aes(x = value, y = resid))+ geom_point(shape = 1)+ geom_hline(yintercept = 0, linetype = &quot;dashed&quot;)+ theme_bw()+ theme(aspect.ratio = 1)+ facet_rep_wrap(~ name, repeat.tick.labels = TRUE, scales = &quot;free&quot;)+ theme_bw()+ labs(x = &quot;&quot;) iph %&gt;% mutate(resid = resid) %&gt;% select(resid, fForested) %&gt;% ggplot(aes(x = fForested, y = resid))+ geom_boxplot()+ theme_bw()+ theme(aspect.ratio = 1) 1.1.5 Check spatial dependence 地理的空間上に残差を図示してもパターンがあるかはわかりにくい。 iph %&gt;% mutate(resid = resid) %&gt;% ggplot(aes(x = Easting, y = Northing))+ geom_point(shape = 21, aes(fill = resid &gt;= 0, size = abs(resid)))+ scale_fill_manual(values = c(&quot;white&quot;,&quot;black&quot;))+ theme_bw()+ theme(aspect.ratio = 1) 図1.1: Residuals plotted versus spatial position. The width of a point is proportional to the (absolute) value of a residual. Filled circles are positive residuals and open circles are negative residuals. It would be useful to add the contour lines of the Irish borders. そこで、バリオグラムを作成する。 バリオグラムではまず、データ間の距離がある特定の範囲内にあるデータのペアを抽出する。例えば、図1.2は10kmずつに区切った範囲内にある2つのデータをつないだものである。そのうえで、ある距離範囲カテゴリ(e.g., 10km &lt; dist &lt; 20km)において各データペアの残差の差の二乗を平均したものを算出する。これを全距離範囲カテゴリについて行い、それを図示したものをバリオグラムという。なお、各範囲カテゴリには、少なくとも100ペアくらいはあった方がよい。 crossing(ID1 = iph$ID, ID2 = iph$ID) %&gt;% left_join(iph %&gt;% select(ID,Easting, Northing), by = c(&quot;ID1&quot; = &quot;ID&quot;)) %&gt;% rename(Easting1 = Easting, Northing1 = Northing) %&gt;% left_join(iph %&gt;% select(ID,Easting, Northing), by = c(&quot;ID2&quot; = &quot;ID&quot;)) %&gt;% rename(Easting2 = Easting, Northing2 = Northing) %&gt;% filter(ID1 != ID2) %&gt;% mutate(dist = sqrt((Easting1 - Easting2)^2 + (Northing1 - Northing2)^2)/1000) %&gt;% mutate(cat = ifelse(dist &lt; 10, &quot;Distances &lt; 10 km&quot;, ifelse(dist &lt; 20, &quot;10 km &lt; Distances &lt; 20 km&quot;, ifelse(dist &lt; 30, &quot;20 km &lt; Distances &lt; 30 km&quot;, ifelse(dist &lt; 40, &quot;30 km &lt; Distances &lt; 40 km&quot;, &quot;NA&quot;))))) %&gt;% mutate(cat2 = ifelse(dist &lt; 40, 1, ifelse(dist &lt; 30, 2, ifelse(dist &lt; 20, 3, ifelse(dist &lt; 10, 4, &quot;NA&quot;))))) %&gt;% filter(cat != &quot;NA&quot;) %&gt;% mutate(cat = fct_relevel(cat, &quot;Distances &lt; 10 km&quot;)) %&gt;% ggplot()+ geom_segment(aes(x = Easting1, xend = Easting2, y = Northing1, yend = Northing2), data = . %&gt;% filter(cat2 == &quot;1&quot;))+ geom_segment(aes(x = Easting1, xend = Easting2, y = Northing1, yend = Northing2), data = . %&gt;% filter(cat2 == &quot;2&quot;))+ geom_segment(aes(x = Easting1, xend = Easting2, y = Northing1, yend = Northing2), data = . %&gt;% filter(cat2 == &quot;3&quot;))+ geom_segment(aes(x = Easting1, xend = Easting2, y = Northing1, yend = Northing2), data = . %&gt;% filter(cat2 == &quot;4&quot;))+ facet_rep_wrap(~cat, repeat.tick.labels = TRUE)+ theme_bw()+ theme(aspect.ratio = 1)+ labs(x = &quot;Easting&quot;, y = &quot;Northing&quot;) 図1.2: Each panel shows c ombinations of any two sampling locations with distances of certain threshold values. もしデータに空間的な相関がないのであれば、距離の範囲カテゴリに関わらずデータペアの残差の差の平均は一定になるはずである(= バリオグラムはx軸と平行になる)。一方で、例えば空間的に近いデータほど似た残差をとるのであれば、近い距離範囲カテゴリではデータペアの残差の差の平均が小さくなる。 Rでは以下のように実行できる。cressie = TRUEとすることで推定がより頑強になり、外れ値の影響を小さくすることができる。npは各距離範囲カテゴリのデータ数を、distはそれぞれの距離カテゴリーにおけるデータ間の平均距離、gammaは計算されたバリオグラムの値を表す。明らかにプロットは一定の値をとっておらず、強い空間相関があることが予想される。 vario_2_3 &lt;- data.frame(resid = rstandard(m2_3), Easting.km = iph$Easting/1000, Northing.km = iph$Northing/1000) sp::coordinates(vario_2_3) &lt;- c(&quot;Easting.km&quot;, &quot;Northing.km&quot;) vario_2_3 %&gt;% variogram(resid ~ 1, data = ., cressie = TRUE, ## 距離が150km以下のデータのみ使用 cutoff = 150, ## 各距離範囲カテゴリの範囲 width = 10) %&gt;% ggplot(aes(x = dist, y = gamma))+ geom_point(aes(size = np))+ theme_bw()+ theme(aspect.ratio = 1)+ labs(y = &quot;semivariogram&quot;) 南北方向と東西方向の距離を分けて調べることもできる。特に東西方向では明確にバリオグラムが水平ではなく、空間的な独立性がないことが分かる。 vario_2_3 %&gt;% variogram(resid ~ Easting.km + Northing.km, data = ., ## 0が南北方向、90が東西方向 alpha = c(0, 90), cressie = TRUE, cutoff = 150, width = 10) %&gt;% ggplot(aes(x = dist, y = gamma))+ geom_point(aes(size = np))+ theme_bw()+ theme(aspect.ratio = 1)+ facet_rep_wrap(~ dir.hor, labeller = as_labeller(c(&quot;0&quot; = &quot;North-South&quot;, &quot;90&quot; = &quot;East-West&quot;)))+ labs(y = &quot;semivariogram&quot;) 1.2 GAM applied to temporal data 1.2.1 Subnivium temperature data 本節では、 Petty et al. (2015) のデータを用いる。この論文では雪下と地面の間の環境(subnivium)の温度を調べている。積雪量が温度に与える影響を、米ウィスコンシン州の3か所の3つの異なる環境(tall grass prailies, deciduous, coniferous)で検討している。 2013年12月から2014年3月における、日ごとの平均温度が記録されている。各環境に4つずつデータロガーが置かれている。そのため、\\(3 \\times 4 = 12\\)個の時系列データがある。 sn &lt;- read_csv(&quot;data/Snow.csv&quot;) %&gt;% mutate(date = as_datetime(str_c(Year,Month, Day, sep = &quot;-&quot;))) %&gt;% mutate(date_num = as.numeric((date - min(date))/(3600*24)) + 1) datatable(sn, options = list(scrollX = 20), filter = &quot;top&quot;) 論文に倣い、2013年12月5日から2014年3月3日までのデータを用いる(4 &lt;= date_num &lt;= 92)。 sn2 &lt;- sn %&gt;% filter(date_num &gt;= 4 &amp; date_num &lt;= 92) 各環境における温度の変化は以下の通り。 sn2 %&gt;% ggplot(aes(x = date_num, y = Temp))+ geom_line(aes(linetype = Logger))+ facet_rep_wrap(~Type)+ theme_bw()+ theme(aspect.ratio = 1.2) 1.2.2 Sources of dependency 同じ環境のロガーはそれぞれ10mしか離れていないので、同じ日におけるこれらのロガーのデータは独立ではない。また、同じロガーのデータについても、時間的な相関があると考えられる(t-1日目の温度とt日目の温度が独立とは考えにくい)。各環境間は距離が離れているので、独立性があると仮定してよさそう。 以下では、こうした非独立性を考慮せずに分析をした場合にどのような問題がが生じるかを見ていく。 1.2.3 The model 以下のGAMMを適用する。ロガーIDをランダム切片として入れている。環境ごとにsmootherを推定する。\\(t\\)は経過日数(date_num)、\\(i\\)はロガーのidを表す。 \\[ \\begin{aligned} T_{it} &amp;\\sim N(\\mu_t, \\sigma^2)\\\\ \\mu_{it} &amp;= \\alpha + f_j(date\\_num_t) + Type_i + a_i\\\\ a_i &amp;\\sim N(0, \\sigma_{Logger}^2) \\end{aligned} \\] Rでは以下のように実行する。 m2_4 &lt;- gamm(Temp ~ s(date_num, by = Type) + Type, random = list(Logger =~ 1), data = sn2 %&gt;% mutate(Type = as.factor(Type))) 結果は以下の通り。 summary(m2_4$gam) ## ## Family: gaussian ## Link function: identity ## ## Formula: ## Temp ~ s(date_num, by = Type) + Type ## ## Parametric coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) -1.7363 0.1796 -9.670 &lt;2e-16 *** ## TypeDeciduous -0.1378 0.2574 -0.535 0.5927 ## TypePrairie 0.5000 0.2551 1.960 0.0503 . ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Approximate significance of smooth terms: ## edf Ref.df F p-value ## s(date_num):TypeConiferous 8.658 8.658 36.21 &lt;2e-16 *** ## s(date_num):TypeDeciduous 8.205 8.205 62.67 &lt;2e-16 *** ## s(date_num):TypePrairie 8.229 8.229 37.69 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## R-sq.(adj) = 0.548 ## Scale est. = 1.0144 n = 921 summary(m2_4$lme) ## Linear mixed-effects model fit by maximum likelihood ## Data: strip.offset(mf) ## AIC BIC logLik ## 2787.212 2840.292 -1382.606 ## ## Random effects: ## Formula: ~Xr - 1 | g ## Structure: pdIdnot ## Xr1 Xr2 Xr3 Xr4 Xr5 Xr6 Xr7 Xr8 ## StdDev: 20.28316 20.28316 20.28316 20.28316 20.28316 20.28316 20.28316 20.28316 ## ## Formula: ~Xr.0 - 1 | g.0 %in% g ## Structure: pdIdnot ## Xr.01 Xr.02 Xr.03 Xr.04 Xr.05 Xr.06 Xr.07 Xr.08 ## StdDev: 16.03337 16.03337 16.03337 16.03337 16.03337 16.03337 16.03337 16.03337 ## ## Formula: ~Xr.1 - 1 | g.1 %in% g.0 %in% g ## Structure: pdIdnot ## Xr.11 Xr.12 Xr.13 Xr.14 Xr.15 Xr.16 Xr.17 Xr.18 ## StdDev: 14.19846 14.19846 14.19846 14.19846 14.19846 14.19846 14.19846 14.19846 ## ## Formula: ~1 | Logger %in% g.1 %in% g.0 %in% g ## (Intercept) Residual ## StdDev: 0.3414393 1.007198 ## ## Fixed effects: y ~ X - 1 ## Value Std.Error DF t-value p-value ## X(Intercept) -1.736302 0.1798447 906 -9.654451 0.0000 ## XTypeDeciduous -0.137767 0.2578500 9 -0.534292 0.6061 ## XTypePrairie 0.499994 0.2555270 9 1.956717 0.0821 ## Xs(date_num):TypeConiferousFx1 -1.238174 1.0476349 906 -1.181875 0.2376 ## Xs(date_num):TypeDeciduousFx1 3.652453 1.4161295 906 2.579180 0.0101 ## Xs(date_num):TypePrairieFx1 0.042635 1.1659387 906 0.036567 0.9708 ## Correlation: ## X(Int) XTypDc XTypPr X(_):TC X(_):TD ## XTypeDeciduous -0.697 ## XTypePrairie -0.704 0.491 ## Xs(date_num):TypeConiferousFx1 -0.001 0.001 0.001 ## Xs(date_num):TypeDeciduousFx1 0.000 0.004 0.000 0.000 ## Xs(date_num):TypePrairieFx1 0.000 0.000 0.001 0.000 0.000 ## ## Standardized Within-Group Residuals: ## Min Q1 Med Q3 Max ## -5.0136973 -0.4288093 0.0765251 0.5515962 3.2003331 ## ## Number of Observations: 921 ## Number of Groups: ## g g.0 %in% g ## 1 1 ## g.1 %in% g.0 %in% g Logger %in% g.1 %in% g.0 %in% g ## 1 12 1.2.4 Model validation ロガーごとの標準化残差を時系列的に図示したのが下図である。ここからパターンを読み取るのは難しい。 sn2 %&gt;% mutate(resid = resid(m2_4$lme, type = &quot;n&quot;)) %&gt;% ggplot(aes(x = date_num, y = resid))+ geom_point()+ geom_smooth(color = &quot;grey23&quot;)+ facet_rep_wrap(~Logger, scales = &quot;free_y&quot;) 時系列相関があるかを調べるためには、自己相関関数(acf)を描くことが有効である。自己相関関数は、k時点前のデータとの相関をkの関数としてあらわしたものである。 以下で、ロガーごとに時系列相関を算出する。 sn2 %&gt;% mutate(resid = resid(m2_4$lme, type = &quot;n&quot;)) %&gt;% group_by(Logger) %&gt;% arrange(date_num, .by_group = TRUE) -&gt; sn3 Loggerid &lt;- unique(sn3$Logger) all.out &lt;- NULL for(i in seq_along(Loggerid)){ data &lt;- sn3 %&gt;% filter(Logger == Loggerid[i]) ## 各ロガーについて時系列相関を算出 out.acf &lt;- acf(data$resid, lag.max = 15, plot = FALSE) ## 出力をデータフレームに out.df &lt;- data.frame(Timelag = out.acf$lag, Acf = out.acf$acf, SE = qnorm(0.975)/sqrt(out.acf$n.used), ID = Loggerid[i]) ## 全て結合 all.out &lt;- bind_rows(all.out, out.df) } 図示したのが下図である。グレーの塗りつぶしは95%信頼区間を表している。図から、全てのロガーにおいて1時点前のデータとの相関が高いことが示唆される。これは、残差に時系列相関があることを示しており、これを考慮したモデルを作成する必要性を示唆している。 all.out %&gt;% ggplot(aes(x = Timelag, y = 0))+ geom_segment(aes(xend = Timelag, yend = Acf))+ geom_ribbon(aes(ymax = SE, ymin = -SE), alpha = 0.3)+ theme_bw()+ theme(aspect.ratio = 0.8)+ facet_rep_wrap(~ID, repeat.tick.labels = TRUE)+ labs(y = &quot;Auto-correlation&quot;) acfの代わりにバリオグラムを用いることもできる。これは、時間間隔が一定でない場合などに有効である。これについては後でもう一度触れる。 References "],["Chapter3.html", "2 Time series and GLS 2.1 Ospreys 2.2 Covariance and correlation coefficients 2.3 Linear regression models 2.4 Focusing on the residual covariance matrix 2.5 Dependency and the covariance matrix 2.6 Dealing with temporal dependency", " 2 Time series and GLS 本章では、時系列データに対して用いることができる回帰モデルについて解説する。 2.1 Ospreys Steidl et al. (1991) は、ミサゴの卵の厚さが殺虫剤の崩壊産物(DDD)によって変わるかを調べ、有意な関連を見つけた。本節ではこのデータを用いる。 osp &lt;- read_csv(&quot;data/Ospreys.csv&quot;) datatable(osp, options = list(scrollX = 20), filter = &quot;top&quot;) 2.2 Covariance and correlation coefficients DDDと卵の殻の厚さの関連は以下の通り。 osp %&gt;% ggplot(aes(x = DDD, y = THICK))+ geom_point(shape = 1, size = 2)+ theme_bw()+ theme(aspect.ratio=1) 相関係数は-0.42である。 cor(osp$THICK, osp$DDD) ## [1] -0.4195692 2.3 Linear regression models 以下のモデルを考える。 \\[ \\begin{aligned} Thichness_i &amp;= \\beta_1 + \\beta_2 \\times DDD_i + \\epsilon_i \\\\ \\epsilon_i &amp;\\sim N(0, \\sigma^2) \\end{aligned} \\] Rでは以下のように実行する。 m3_1 &lt;- lm(THICK ~ DDD, data = osp) 2.4 Focusing on the residual covariance matrix 残差\\(\\epsilon_i\\)は行列式で以下のように書ける。なお、\\(\\bf{I}\\)は単位行列である。 \\[ \\bf{\\epsilon} \\sim N(0, \\bf{\\sigma^2} \\times \\mathbf{I}) \\] より一般的に、残差\\(\\epsilon_i\\)は以下のように書ける。\\(\\bf{\\Sigma}\\)は分散共分散行列と呼ばれる。 \\[ \\bf{\\epsilon} \\sim N(0, \\bf{\\Sigma}) \\] 通常の線形回帰モデルでは、\\(\\bf{\\Sigma}\\)は以下のようになる。ここで、\\(sigma^2\\)に単位行列を書けるということは、残差間が独立であることを仮定していることになる。例えば、1行2列目は\\(\\epsilon_1\\)と\\(\\epsilon_2\\)の共分散を表すが、単位行列ではこれが0になる。同様に、単位行列は対角成分以外が全て0になるので、異なる残差同士の共分散が全て0になると仮定していることになる。 \\[ \\bf{\\Sigma} = \\sigma^2 \\times \\mathbf{I} \\] より一般的には、分散共分散行列\\(\\bf{\\Sigma}\\)は以下のように書ける。これは対称行列である。\\(\\phi_{i,j}\\)は\\(\\epsilon_i\\)と\\(\\epsilon_j\\)の共分散である。通常の回帰分析ではこれらが全て0と仮定された。共分散が０以外の値をとる場合、異なる残差は独立ではなくなる。 \\[ \\bf{\\Sigma} = \\begin{pmatrix} \\sigma^2 &amp; \\phi_{1,2} &amp; \\phi_{1,3} &amp; \\phi_{1,4} &amp; \\cdots &amp;\\phi_{1,25} \\\\ &amp; \\sigma^2 &amp; \\phi_{2,3} &amp; \\phi_{2,4} &amp; \\cdots&amp; \\phi_{2,25}\\\\ &amp; &amp; \\sigma^2 &amp; \\phi_{3,4} &amp; \\cdots &amp; \\phi_{3,25} \\\\ &amp; &amp; &amp; \\sigma^2 &amp; \\ddots &amp; \\vdots \\\\ &amp; &amp; &amp; &amp; \\sigma^2 &amp; \\phi_{24,25}\\\\ &amp; &amp; &amp; &amp; &amp; \\sigma^2 \\end{pmatrix} \\tag{2.1} \\] 2.5 Dependency and the covariance matrix ここで、回帰モデルにおける分散共分散行列の役割について理解するためにシミュレーションを行う。変数\\(z_1\\)と\\(z_2\\)が以下に従って1000個ずつ得られるとする。 \\[ \\begin{aligned} z_1 &amp;\\sim N(10,1)\\\\ z_2 &amp;\\sim N(15,1) \\end{aligned} \\] Rでは以下のように得る。 set.seed(1234) z1 &lt;- rnorm(1000, 10, 1) z2 &lt;- rnorm(1000, 15, 1) MASSパッケージのmvrnorm関数を用い、多変量正規分布から同様に値を行列として得ることもできる。 sigma &lt;- diag(2) Z &lt;- mvrnorm(1000, mu = c(10, 15), Sigma = sigma) %&gt;% data.frame() %&gt;% rename(z1 = 1, z2 = 2) datatable(Z) このとき、\\(z_1\\)と\\(z_2\\)は行列を用いると以下のように多変量正規分布から得られていると書くことができる。これは、平均がそれぞれ10と15で、分散共分散行列\\(\\bf{\\Sigma}\\)が単位行列の多変量正規分布から値が得られたことを示す。 $$ \\[\\begin{pmatrix} z_1 \\\\ z_2 \\end{pmatrix}\\] = N ( \\[\\begin{pmatrix} 10 \\\\ 15 \\end{pmatrix}\\] , \\[\\begin{pmatrix} 1 &amp; 0 \\\\ 0 &amp; 1 \\\\ \\end{pmatrix}\\] ) $$ 得られたデータをプロ通して分かるように、分散共分散行列が単位行列であり、\\(z_1\\)と\\(z_2\\)の間の共分散はゼロとなっているため、これらに相関が全くないことが分かる。 Z %&gt;% ggplot(aes(x = z1, y = z2))+ geom_point(shape = 1, size = 2)+ theme_bw()+ theme(aspect.ratio = 1) 今度は、\\(z_1\\)と\\(z_2\\)が正の相関を持つような場合を考える。このようなときは、以下のように\\(\\bf{\\Sigma}\\)の\\(\\phi\\)成分を0でなく正の値にしてやればよい(ここでは0.9)。分散を1にしているので、この値はそのまま相関係数になる。 sigma &lt;- diag(2) sigma[1,2] &lt;- 0.9 sigma[2,1] &lt;- 0.9 sigma ## [,1] [,2] ## [1,] 1.0 0.9 ## [2,] 0.9 1.0 実際に得られた値をプロットしても、\\(z_1\\)と\\(z_2\\)が強い相関を持つことが分かる。このように、\\(\\bf{Sigma}\\)の非対角成分に0以外の値を割り当てることで、多変量正規分布から得られる値が非独立であることを表現できる。 Z &lt;- mvrnorm(1000, mu = c(10, 15), Sigma = sigma) %&gt;% data.frame() %&gt;% rename(z1 = 1, z2 = 2) Z %&gt;% ggplot(aes(x = z1, y = z2))+ geom_point(shape = 1, size = 2)+ theme_bw()+ theme(aspect.ratio = 1) 2.6 Dealing with temporal dependency 同様に、時系列データに対しても、残差の分散共分散行列の非対角成分\\(\\phi_{i,j}\\)を0以外の値にすることで、データの非独立性に対処することができる。そのような方法の一つがGLS(Generalized least square)と呼ばれる方法である。 2.6.1 Adelie penguins ここでは、 Barbraud and Weimerskirch (2006) が南極の海鳥が到着する日と産卵日について調査したデータを用いる。ここでは、特に産卵日について着目する。 データは以下の通り。各年について1つのデータがある。 bird &lt;- read_csv(&quot;data/Phenology_Data_Antarcticbirds_AFZ1.csv&quot;) datatable(bird, options = list(scrollX = 20), filter = &quot;top&quot;) 分析では、海氷面積によって産卵日に違いが出るかを調べる。海氷面積の直接的なデータはないので、その近似として海中のメタルスルホン酸(MSA: 海氷が多いと多くなる)を用いる。 産卵日の年変動と、MSAと産卵日の関係は以下のようになる。 bird %&gt;% ggplot(aes(x = Year, y = LayingAP))+ geom_line()+ geom_point()+ theme_bw()+ theme(aspect.ratio = 0.7)+ labs(y = &quot;Laying date&quot;) -&gt; p1 bird %&gt;% ggplot(aes(x = MSA, y = LayingAP))+ geom_point(shape = 1, size = 2)+ theme_bw()+ theme(aspect.ratio = 1)+ labs(y = &quot;Laying date&quot;) -&gt; p2 p1 + p2 2.6.2 Do we have dependency? 産卵日に影響する様々な要因(成熟したメスの数、病気の流行、ホルモンレベル)などは年ごとに独立ではなく、t年のデータがt+1年のデータに影響を及ぼしていると考えられる。よって、各年の産卵日は独立ではないと考えられる。 2.6.3 Formulation of the linear regression model まずは時系列を考慮しない通常の線形回帰モデルを適用する。モデル式は以下の通り。 \\[ \\begin{aligned} LD_t &amp;= \\beta_1 + \\beta_2 \\times MSA_t + \\epsilon_t \\\\ \\epsilon_t &amp;\\sim N(0,\\sigma^2) \\end{aligned} \\] 2.6.4 Application of the linear regression model Rでは以下のように実行する。ここでは、nlmeパッケージのgls関数を用いる(もちろん、lm関数でも実行できる)。 m3_2a &lt;- gls(LayingAP ~ MSA, data = bird, na.action = na.omit) 結果は以下の通り。MSAの効果は弱いことが分かる。 summary(m3_2a) ## Generalized least squares fit by REML ## Model: LayingAP ~ MSA ## Data: bird ## AIC BIC logLik ## 139.7118 144.0137 -66.85588 ## ## Coefficients: ## Value Std.Error t-value p-value ## (Intercept) 247.91825 1.25111 198.15867 0.0000 ## MSA -33.01513 16.42976 -2.00947 0.0533 ## ## Correlation: ## (Intr) ## MSA -0.956 ## ## Standardized residuals: ## Min Q1 Med Q3 Max ## -1.5831272 -0.5845941 -0.1200808 0.5813974 1.9238887 ## ## Residual standard error: 2.111689 ## Degrees of freedom: 33 total; 31 residual モデルの標準化残差と予測値、MSAとの関連をプロットしたのが以下の図である。数字は観察年の下２桁を表す。明確なパターンは見当たらない。しかし、よく見てみると観察年が近いと似た残差をとる傾向があるように思える。例えば、60年代のデータは全て残差が負の値になっている。 data.frame(resid = resid(m3_2a, type = &quot;n&quot;), Year = bird %&gt;% drop_na(LayingAP, MSA) %&gt;% .$Year, fitted = predict(m3_2a), MSA = bird %&gt;% drop_na(LayingAP, MSA) %&gt;% .$Year) %&gt;% mutate(Year2 = str_sub(Year, 3,4)) -&gt; fitted_m3_2a fitted_m3_2a %&gt;% ggplot(aes(x = fitted, y = resid))+ geom_point(shape = 1, size = 2)+ geom_text_repel(aes(label = Year2))+ geom_hline(yintercept = 0, linetype = &quot;dashed&quot;)+ theme_bw(base_size = 14)+ theme(aspect.ratio = 1) -&gt; p1 fitted_m3_2a %&gt;% ggplot(aes(x = MSA, y = resid))+ geom_point(shape = 1, size = 2)+ geom_text_repel(aes(label = Year2))+ geom_hline(yintercept = 0, linetype = &quot;dashed&quot;)+ theme_bw(base_size = 14)+ theme(aspect.ratio = 1) -&gt; p2 p1 + p2 自己相関関数をプロットしてみると、あまり明確にはわからないが有意に自己相関が高いところがあることが分かる。 resid &lt;- rep(NA, nrow(bird)) i &lt;- !is.na(bird$LayingAP) &amp; !is.na(bird$MSA) resid[i] &lt;- resid(m3_2a, type = &quot;n&quot;) acf &lt;- acf(resid, lag.max = 20, na.action = na.pass, plot = FALSE) data.frame(lag = 0:20, acf = acf$acf, SE = qnorm(0.975)/sqrt(acf$n.used)) %&gt;% ggplot(aes(x = lag, y = 0))+ geom_segment(aes(xend = lag, yend = acf))+ geom_hline(aes(yintercept = -SE), linetype = &quot;dashed&quot;, color = &quot;navy&quot;)+ geom_hline(aes(yintercept = SE), linetype = &quot;dashed&quot;, color = &quot;navy&quot;)+ theme_bw()+ labs(y = &quot;acf&quot;)+ theme(aspect.ratio = 1)+ scale_x_continuous(breaks = seq(0,20,1)) 欠損値が多いので、バリオグラムで見た方が適切かもしれない。バリオグラムは以下のようになる。バリオグラムは水平にならず、やはり残差に時間的な相関があることが示唆される。 vario_3_2a &lt;- data.frame(resid = resid, Year = bird$Year, zero = 0) %&gt;% drop_na() sp::coordinates(vario_3_2a) &lt;- c(&quot;Year&quot;, &quot;zero&quot;) vario_3_2a %&gt;% variogram(resid ~ 1, data = ., cutoff = 9, width = 1) %&gt;% ggplot(aes(x = dist, y = gamma))+ geom_line()+ geom_point(size = 3, shape = 21, fill = &quot;black&quot;, color = &quot;white&quot;, stroke = 2)+ theme_bw(base_size = 14)+ theme(aspect.ratio = 1)+ labs(y = &quot;semivariogram&quot;, x = &quot;Time lag&quot;)+ coord_cartesian(ylim = c(0,1.4))+ scale_x_continuous(breaks = seq(1,9,1))+ scale_y_continuous(breaks = seq(0,1.4,0.2)) こうした時系列相関が問題になりうるかを判断するためには、時系列相関を考慮したモデルを作成し、それを考慮しないモデルと比較する必要がある。 2.6.5 Formulation of the GLS model 通常の回帰モデルでは異なる残差同士が独立(相関が0)なので、以下のように書くことができる。 \\[ \\begin{aligned} LD_t &amp;= \\beta_1 + \\beta_2 \\times MSA_t + \\epsilon_t \\\\ \\epsilon_t &amp;\\sim N(0,\\sigma^2)\\\\ cor(\\epsilon_t, \\epsilon_s) &amp;= \\begin{cases} 0 \\; \\bf{if} \\;t \\neq s \\\\ 1 \\; \\bf{if} \\;t = s \\end{cases} \\end{aligned} \\] これまでに見てきたように、時系列相関を考慮するためには異なる残差同士の相関が0でないと仮定すればよい。これは、以下のように書ける。なお、\\(h()\\)は残差同士の相関を決める関数で\\(\\phi\\)はその関数におけるパラメータである。 \\[ \\begin{aligned} LD_t &amp;= \\beta_1 + \\beta_2 \\times MSA_t + \\epsilon_t \\\\ \\epsilon_t &amp;\\sim N(0,\\sigma^2)\\\\ cor(\\epsilon_t, \\epsilon_s) &amp;= h(\\phi, \\epsilon_t, \\epsilon_s) \\end{aligned} \\] 時系列相関を考慮したモデルでは、この\\(h()\\)に様々な関数を想定することで、データの非独立性に対応する。最も一般的なものは、AR1と呼ばれるもので、以下のように書ける。なお、\\(\\phi\\)は0から1の値をとる。 \\[ \\begin{aligned} \\epsilon_t &amp;= \\phi \\times \\epsilon_{t-1} + \\nu_t \\\\ \\nu_t &amp;\\sim N(0, \\sigma_\\nu^2) \\end{aligned} \\] 関数\\(h()\\)は以下のように書ける。このとき、残差は定常性を持つといわれる。これは、残差の共分散は時間差のみに依存しているということである。 \\[ h(\\phi, \\epsilon_t, \\epsilon_s) = \\phi^{|t-s|} \\] AR1で残差の分散共分散行列\\(\\bf{\\Sigma}\\)は以下のように書ける。行列中のパラメータは$$1つなので、これさえ推定できれば良い。 $$ \\[\\begin{pmatrix} 1 &amp; \\phi &amp; \\phi^2 &amp; \\phi^3 &amp; \\cdots &amp; \\phi^{54} \\\\ \\phi &amp; 1 &amp; \\phi &amp; \\phi^2 &amp; \\ddots &amp; \\vdots\\\\ \\phi^2 &amp; \\phi &amp; \\ddots &amp; \\ddots &amp; \\ddots &amp; \\phi^3 \\\\ \\phi^3 &amp; \\phi^2 &amp; \\ddots &amp; \\ddots &amp; \\ddots &amp; \\phi^2 \\\\ \\vdots &amp; \\ddots &amp; \\ddots &amp; \\phi &amp; 1 &amp; \\phi \\\\ \\phi^{54} &amp; \\cdots &amp; \\phi^2 &amp; \\phi^2 &amp; \\phi &amp; 1 \\end{pmatrix}\\] $$ References "],["sessioninfo.html", "実行環境", " 実行環境 sessionInfo() ## R version 4.2.2 (2022-10-31 ucrt) ## Platform: x86_64-w64-mingw32/x64 (64-bit) ## Running under: Windows 10 x64 (build 22621) ## ## Matrix products: default ## ## locale: ## [1] LC_COLLATE=Japanese_Japan.utf8 LC_CTYPE=Japanese_Japan.utf8 ## [3] LC_MONETARY=Japanese_Japan.utf8 LC_NUMERIC=C ## [5] LC_TIME=Japanese_Japan.utf8 ## ## attached base packages: ## [1] parallel splines stats graphics grDevices utils datasets ## [8] methods base ## ## other attached packages: ## [1] fontregisterer_0.3 systemfonts_1.0.4 ## [3] extrafont_0.18 gganimate_1.0.8 ## [5] lemon_0.4.6 ggsci_2.9 ## [7] concaveman_1.1.0 ggforce_0.4.1 ## [9] ggdag_0.2.7 dagitty_0.3-1 ## [11] kableExtra_1.3.4 knitr_1.43 ## [13] DT_0.27 patchwork_1.1.2 ## [15] ggrepel_0.9.2 GGally_2.1.2 ## [17] ggnewscale_0.4.9 htmlwidgets_1.6.2 ## [19] plotly_4.10.1 sp_1.5-1 ## [21] geoR_1.9-2 lubridate_1.9.0 ## [23] timechange_0.1.1 data.table_1.14.6 ## [25] see_0.7.5.5 report_0.5.7.4 ## [27] parameters_0.20.3 performance_0.10.3 ## [29] modelbased_0.8.6.3 insight_0.19.1.4 ## [31] effectsize_0.8.3.6 datawizard_0.7.1.1 ## [33] correlation_0.8.4 bayestestR_0.13.1 ## [35] easystats_0.6.0.8 forcats_1.0.0 ## [37] stringr_1.5.0 dplyr_1.1.2 ## [39] purrr_1.0.0 readr_2.1.3 ## [41] tidyr_1.2.1 tibble_3.2.1 ## [43] ggplot2_3.4.2 tidyverse_1.3.2 ## [45] ggeffects_1.1.4 DHARMa.helpers_0.0.0.9000 ## [47] DHARMa_0.4.6 cmdstanr_0.5.3 ## [49] rstan_2.26.13 StanHeaders_2.26.13 ## [51] brms_2.18.0 Rcpp_1.0.11 ## [53] gstat_2.1-1 gratia_0.8.1.34 ## [55] gamlss_5.4-12 gamlss.dist_6.0-5 ## [57] MASS_7.3-58.1 gamlss.data_6.0-2 ## [59] gamm4_0.2-6 lme4_1.1-34 ## [61] Matrix_1.5-1 mgcv_1.8-41 ## [63] nlme_3.1-160 ## ## loaded via a namespace (and not attached): ## [1] estimability_1.4.1 spacetime_1.3-0 coda_0.19-4 ## [4] intervals_0.15.4 bit64_4.0.5 dygraphs_1.1.1.6 ## [7] inline_0.3.19 generics_0.1.3 callr_3.7.3 ## [10] mvnfast_0.2.8 bit_4.0.5 tzdb_0.3.0 ## [13] webshot_0.5.4 xml2_1.3.5 httpuv_1.6.7 ## [16] assertthat_0.2.1 gargle_1.2.1 xfun_0.39 ## [19] hms_1.1.3 jquerylib_0.1.4 bayesplot_1.10.0 ## [22] evaluate_0.21 promises_1.2.0.1 fansi_1.0.3 ## [25] progress_1.2.2 dbplyr_2.2.1 readxl_1.4.1 ## [28] igraph_1.3.5 DBI_1.1.3 reshape_0.8.9 ## [31] tensorA_0.36.2 googledrive_2.0.0 stats4_4.2.2 ## [34] ellipsis_0.3.2 crosstalk_1.2.0 backports_1.4.1 ## [37] V8_4.2.2 bookdown_0.34 markdown_1.7 ## [40] RcppParallel_5.1.6 vctrs_0.6.2 abind_1.4-5 ## [43] cachem_1.0.6 withr_2.5.0 checkmate_2.1.0 ## [46] vroom_1.6.0 emmeans_1.8.3 xts_0.12.2 ## [49] prettyunits_1.1.1 svglite_2.1.1 splancs_2.01-44 ## [52] lazyeval_0.2.2 crayon_1.5.2 pkgconfig_2.0.3 ## [55] labeling_0.4.2 tweenr_2.0.2 rlang_1.1.1 ## [58] lifecycle_1.0.3 miniUI_0.1.1.1 colourpicker_1.2.0 ## [61] extrafontdb_1.0 modelr_0.1.10 cellranger_1.1.0 ## [64] distributional_0.3.2 tcltk_4.2.2 polyclip_1.10-4 ## [67] matrixStats_0.63.0 loo_2.5.1 boot_1.3-28 ## [70] zoo_1.8-11 reprex_2.0.2 base64enc_0.1-3 ## [73] processx_3.8.0 googlesheets4_1.0.1 viridisLite_0.4.2 ## [76] shinystan_2.6.0 scales_1.2.1 magrittr_2.0.3 ## [79] plyr_1.8.8 threejs_0.3.3 compiler_4.2.2 ## [82] rstantools_2.2.0 RColorBrewer_1.1-3 cli_3.6.0 ## [85] ps_1.7.2 Brobdingnag_1.2-9 tidyselect_1.2.0 ## [88] stringi_1.7.8 highr_0.10 yaml_2.3.7 ## [91] bridgesampling_1.1-2 grid_4.2.2 sass_0.4.5 ## [94] tools_4.2.2 rstudioapi_0.15.0 gridExtra_2.3 ## [97] posterior_1.3.1 farver_2.1.1 digest_0.6.31 ## [100] FNN_1.1.3.2 shiny_1.7.4 broom_1.0.2 ## [103] later_1.3.0 httr_1.4.4 colorspace_2.0-3 ## [106] rvest_1.0.3 fs_1.5.2 shinythemes_1.2.0 ## [109] xtable_1.8-4 jsonlite_1.8.4 nloptr_2.0.3 ## [112] tidygraph_1.2.2 R6_2.5.1 pillar_1.9.0 ## [115] htmltools_0.5.4 mime_0.12 glue_1.6.2 ## [118] fastmap_1.1.0 minqa_1.2.5 codetools_0.2-18 ## [121] ggokabeito_0.1.0 pkgbuild_1.4.0 mvtnorm_1.1-3 ## [124] utf8_1.2.2 lattice_0.20-45 bslib_0.4.2 ## [127] curl_4.3.3 gtools_3.9.4 magick_2.7.4 ## [130] shinyjs_2.1.0 Rttf2pt1_1.3.8 survival_3.5-5 ## [133] rmarkdown_2.23 munsell_0.5.0 haven_2.5.1 ## [136] reshape2_1.4.4 gtable_0.3.3 References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
